# Stores

Solid's stores simplify state management through creating a centralized location for logic to reduce code redundancy.
Stores use immutable patterns to make it easier to manage reactivity and flow of data, which make them a better candidate for more complex state management scenarios.

Similar to [signals](/essentials/signals), stores are a way to store state.
However, while signals are designed to hold individual values, stores can contain a collection, where each element can be a signal.

## Creating a store

The `createStore` call takes an initial value and returns a read/write tuple similar to a [signal](/concepts/signals).

```jsx
import { createStore } from "solid-js/store";

const [store, setStore] = createStore([{
    name: "Ryan",
    online: false,
  },
  {
    name: "Dave",
    online: true,
  },
  {
    name: "Milo",
    online: true,
  },
  {
    name: "Maddy",
    online: false,
  }
  ])
```

## Accessing values

The first value returned by the `createStore` function is a read-only proxy that helps you access properties within a store.
This method ensures that your component consistently reflects the current value of the store's properties.

```jsx
<span>{store.users[0].name}</span>
```

## Updating stores

When you want to modify a store, you use the second value returned by the `createStore`.
The purpose of this setter is to provide a means for reactively updating the store.
This helps to keep any component or computations dependent on the store updated whenever the store's state changes.

```jsx
  setStore(0, "online", true)
```

One important feature of the setter functions in stores is their **path syntax**. 
This allows you to identify the state's keys as the initial arguments and provide the new value for the identified key as the last one. 
If you have worked with JavaScript, this might remind you of how to assign a value in an object: `object[key] = newValue`.

```jsx
// js
store[1][online] = true

// solid
setStore( 1, "name", "David")
```

### Maintaining reactivity

When you create a store, it contains the initial state, but no signals are immediately created to track changes to that state. 
These signals are created lazily, meaning they come into existence only when you access the data within a reactive context.

When you use this data within a reactive context, such as in a template or a computed property, that is when the signals are created and dependencies are established.

```jsx
// not reactive
setStore( 1, "online", status => !status)

// reactive
const updateStatus = createMemo(() => {
  setStore( 1, online, status => !status)
})
```

### Modifying values in arrays

Path syntax provides a convenient way to modify arrays, making it easier to access and update their elements.
Instead of relying on discovering individual indices, path syntax introduces several powerful techniques for array manipulation.

#### Range specification

With path syntax, you can specify a range of indices to update or modify, using an object with `from` and `to` keys.
This provides you with a way to target a subset of the elements within the array for modification.

```jsx
setStore({from: 1, to: 3}, "online", false)
```

In addition to this, you can specify multiple select keys using an array:

```jsx
setStore([1,3], "online", false)
```

Including the `by` key, can help you perform iterative updates within an array, which can be useful when you want to update elements at regular intervals.
This key defines the step size for index increments, similar to a [`for` loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for):

```jsx
setStore({from: 0, to: store.length-1, by:2}, "online", false)
```

#### Dynamic value assignment

Path syntax enables you to set values within an array using functions instead of static values.
These functions receive the old value as an argument, allowing you to compute the new value based on the existing one.
This dynamic approach is particularly useful for complex transformations.

```jsx
  setStore(2,
    (user) => !user.online,
  );
```

#### Filtering values

In scenarios where you want to update elements in an array based on a specific condition, you can pass a function as an argument. 
This function will act as a filter, allowing you to select elements that satisfy the condition. 
It receives the old value and index as arguments, providing the flexibility to make conditional updates.

```jsx
setStore(
    (user, index) => user.name.startsWith('M'),
    'online',
    true
  );
```

In addition to [`.startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith), you can use other array methods like [`.find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) to filter for the values that you need. 

#### Appending new values

To append a new element to an array within a store, you specify the target array and set the index to the desired position.
For example, if you wanted to append the new element to the end of the array, you would set the index to `array.length`:

```jsx
 const newUser = (newUser, status) => {
  setUser(
    "users", 
    store.users.length, {
      name: newUser,
      online: status,
    })
 }
```

## Objects in stores



## Store utilities

### `produce`

Even with the many capabilities of `setState`, there are instances where you may want to work with the writeable proxy version of your store.
The `produce` method was created to facilitate working with immutable data structures in a more mutuable-fashion. 
This method provides a way to perform mutations as if working with regular JavaScript objects but, upon completion, produces a *new state* with all the changes applied in an **immutable** manner.

```jsx
import { produce } from "solid-js/store";

const [store, setStore] = createStore({
  user: {
    name: "John",
    age: 30,
  },
  products: [
    { id: 1, name: "Product A" },
    { id: 2, name: "Product B" },
  ],
});

setStore(produce(store, (draft) => {
    draft.user.name = "Updated Name";
  })
  )
```

Some advantages to using `produce`:
*  Handling deeply nested state objects or arrays with `produce` eliminates the verbosity often associated with the `setState` path syntax.

* `produce` ensures that the original state is untouched.
This reduces the risk of unexpected mutations and the bugs they can introduce.

* It only generates a new object when there's a change.

* In more complex applications, `produce` offers a structured and consistent approach to state updates, making the codebase easier to manage and debug.

### `reconcile`

The `reconcile` utility function performs a recursive diff operation on a new value when used in conjunction with store setters.
What this does is allow you to handle new values that you may not have full control over, such as data retrieved from an API response or user-imported data.

You can use reconcile to update the state in a way that only triggers updates for the parts of the data that have changed, reducing unnecessary re-rendering.

```jsx
import { createStore, reconcile } from 'solid-js/store'

const [data, setData] = createStore({
  colors: ['red', 'blue', 'orange']
})

const userColors = getUserColors() // new data, e.g., ["red", "blue", "orange", "black"]

setData('colors', reconcile(userColors)) // updated store: ["red", "blue", "orange", "black"]
```

### `unwrap`

When you wish to convert a store into a regular JavaScript object, you can use `unwrap`.
This can be useful when you need to work with the data in a non-reactive manner or pass it to functions or libraries that don't require reactivity.

```jsx
import { createStore, unwrap } from 'solid-js/store'

const [data, setData] = createStore({
  colors: ['red', 'blue', 'orange']
})

const rawData = unwrap(data)
```

To see how stores work in action, visit the [complex state management guide](/guides/complex-state-management).