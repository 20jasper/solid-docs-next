<Title>Actions</Title>

One question you will likely have when developing any sort of app is "how do I communicate new information to my server?". Solid's answer to this is _actions_. Actions give you an asynchronous function and elegant tools to help you easily manage and track submissions. They generally represent a `POST` request.

## Actions

Actions are isomorphic. This means that a submission can be handled on the server _or_ the client, which ever is optimal. They represent the server component of a [HTML form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form), and even help you use HTML forms to submit data.

### Creating actions

Let's stop getting ahead of ourselves! First let's create an action!

```tsx twoslash
// @lib: ES2015
import { createRouteAction } from "solid-start/data";

export function MyComponent() {
  const action = createRouteAction(async (message: string) => {
    // Imagine this is a call to fetch
    await new Promise((resolve, reject) => setTimeout(resolve, 1000));
    console.log(message);
  });
}
```

This echo action will act as your backend, however you can substitute it for any API, provided you are ok with it running on the client. Typically, route actions are used with some sort of solution like fetch or graphql, and return either a `Response` such as a redirect (we are not returning anything quite yet!) or any promise. If you want to ensure the action only runs on the server for things like databases, you will want to use a different function explained below.

Naturally, this action won't do anything quite yet. We still need to call it somewhere! For now, let's call it manually from some component using the `submit` method.

```ts twoslash {3,8}
// @lib: ES2015
import { createRouteAction } from "solid-start/data";
export function MyComponent() {
  const action = createRouteAction(async (message: string) => {
    // Imagine this is a call to fetch
    await new Promise((resolve, reject) => setTimeout(resolve, 1000));
    console.log(message);
  });
  action.submit("Hello from solid!");
}
```

You should see `Hello from solid!` back in the console!

### Returning from actions

In many cases, after submitting data the server sends some data back as well. Anything returned from your action function can be accessed using the reactive `action.value` property. The value of this property can change each time you submit your action.

```tsx twoslash {2,4,7-9}
// @lib: ES2015
import { createRouteAction } from "solid-start/data";
// ---cut---
export function MyComponent() {
  const action = createRouteAction(async (message: string) => {
    await new Promise((resolve, reject) => setTimeout(resolve, 1000));
    return message;
  });

  action.submit("Hello from solid!");
  setTimeout(() => action.submit("This is a second submission!"), 1500);
  return <p>{action.value}</p>;
}
```

While this method of using actions works, it leads the implementation details of how you trigger `action.submit` up to you. When handling explicit user input, it's better to use a form.

#### Responses

### Using forms to submit data

We highly recommend using HTML forms as your method to submit data with actions. HTML forms can be used even before JavaScript loads, leading to instantly interactive applications. They have the added benefit of implicit accessibility, and can save you valuable time that would have otherwise been spent designing a UI library that will never have the aforementioned benefits.

Forms become available when your action signature matches `(formData: FormData) => Response`. Writing forms using actions is trivial, simply use the `Form` method of your action instead of the normal `<form>` tag, and walk away with amazing, progressively enhanced forms!

```tsx
export function MyComponent() {
  return (
    <action.Form>
      <label for="username">Username:</label>
      <input type="text" name="username" />
      <input type="submit" value="submit" />
    </action.Form>
  );
}
```

The only difference between `action.Form` and a normal form is that `action.Form` calls the action as it's submit handler automatically.

- `createAction`

  - retriggers route resources
  - what does it give you:
    - `action.submissions()` a signal to track the ongoing and failed submissions
  - Errors, each submission state has an error field that's populated if the submission errored, and a status field that's set to `error`
    - if you read the `submissionState.error` field in your code (JSX, or effects) then the error is considered user-handled and we don't trigger ErrorBoundaries.
    - if you don't use the error field, then we trigger the error boundary on an error because we assume its unexpected for you

```tsx
action.submitWithKey(args, key);

action.submissions() = {
  submission1: {
    error: null | Error,
  },
  submission2: {},
};
```

## Server Actions

It is preferable to

- `createServerAction`
  - if you want to run your action on the server only and access your database
