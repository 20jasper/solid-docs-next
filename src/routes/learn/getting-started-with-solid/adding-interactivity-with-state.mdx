import { BasicCounter } from "../components/BasicCounter";

<title>Adding Interactivity with State</title>

In the previous lesson, we learned how to architect a Solid application using components and JSX. We then built a Bookshelf application using our new knowledge, but it's not quite complete. In this lesson, we'll learn about some building blocks that help us _manage application state_. We will then apply this knowledge to our Bookshelf application to bring it to life.

## A note on primitives

As we proceed through these tutorials, we'll start hearing about Solid _primitives_. Primitives are the building blocks of Solid applications. The first primitive that we'll be learning about is the _signal_.

## Managing basic state with signals

In Solid, the most basic way to manage state in our application is to use a _signal_. To create a signal, Solid provides a `createSignal` function:

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);
```

There's a lot going on here: first, we call `createSignal` with the initial value of state. In this case, our `count` is going to start at `0`. The `createSignal` function returns a two-element array and we use JavaScript _destructuring assignment_ to unpack this array. In this case, we assign the first element to a variable called `count` and the second element to a variable called `setCount`.

The first element, `count`, is an _accessor_ function (also referred to as a _getter_) that returns the current value of state. It's important to note that this is a _function that gets the current value_ rather than the value itself.

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);

console.log(count()); // 0
```

The second element, `setCount`, is a _setter_ function. If we want to increment our `count`, we can pass `count() + 1` to `setCount`:

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);

setCount(count() + 1);

console.log(count()); // 1
```

Note that, in order to see our `count` value's new value, we added our `console.log` statement after we used `setCount`.

A key to Solid's _reactive system_ is that we don't really have to do this. Instead, we can listen for&mdash;and instantly react to&mdash;any signal changes by using our next primitive: the _effect_.

## Reacting to changes with effects

The ability to react to signal changes underpins Solid's reactive system. The most basic way to do so is to use an _effect_. We can create an effect by using the `createEffect` hook:

```jsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});

setCount(count() + 1);
```

To use `createEffect`, we pass it a function that will run whenever any signals on which that function depends update.

In this example, our effect depends on `count` and therefore the effect runs whenever `count` changes. Accordingly, we log `1` to the console just like before.

Automatic effect dependency tracking is made possible by `count` being a function. When the `count` function is called inside an effect, that effect is registered as a listener for the signal. This is why it's so important that our signals are functions!

## Rendering with signals

Now that we've gained some exposure to two of Solid's core primitives, signals and effects, it's time to add them into our components. Let's keep using our `count` example but, instead of logging the count, let's render it to the DOM:

```jsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  return <div>Current count: {count()}</div>;
}
```

<div>Current count: 0</div>

We see that, much like other variables, we can use signals inside our JSX code by including them inside curly braces. This component is not too interesting yet; so let's add the ability to increment our count. We can do this by adding `<button>` element and giving it a _click handler_. This click handler will increment our count by using the `setCount` function:

```jsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  const increment = () => {
    setCount(count() + 1);
  };

  return (
    <div>
      Current count: {count()}
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

<BasicCounter />

And now we have a functioning counter! Notably, our DOM updates whenever our `count` is incremented. Does this remind you of an effect? It should! In Solid, rendering is treated as an effect.
