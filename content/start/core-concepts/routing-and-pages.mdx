import { Aside } from "~/components/FrameworkAside";

<Title>Routing & pages</Title>

Routing is the foundation of SolidStart. SolidStart uses the excellent [Solid Router](https://github.com/solidjs/solid-router) behind the scenes and enables _isomorphic routing_: the ability to write routes code once and have it work on both the server and client. In this section, you'll learn how to write basic routes, navigate between routes, and handle more complex/dynamic routing scenarios.

## Creating a route

SolidStart uses file system-based routing. This means that the directory path of your route files will translate exactly to the route structure in your application.

Here are a few examples of files in our directory structure and how they would translate to application routes:

- `/src/routes/index.tsx` -> mysite.com
- `/src/routes/admin/index.tsx` -> mysite.com/admin
- `/src/routes/admin/edit-settings.tsx` -> mysite.com/admin/edit-settings

Under the hood, SolidStart is able to traverse this directory structure, automatically collect all the routes, and give you the `<FileRoutes />` component. You can use this component to specify your routes to the `<Routes />` component in `root.tsx`. This means that all you have to do is create a route in your directory structure and SolidStart takes care of everything else needed to make that route available to visit in your application!

### Route file structure

For routing to work, each route file should export a default component. This component represents the content that will be rendered when users visit the route:

```tsx
export default function Index() {
  return <div>Welcome to SolidStart!</div>;
}
```

In this example, visiting mysite.com/ will render a `<div>` with the text "Welcome to SolidStart!" inside it.

### Using route data

In many cases, we need to do more than just render some HTML&mdash;we need to also pass some data to our route. For this, we can export a named `routeData` function. In this example, we'll greet the user by name:

```tsx
import { useRouteData } from "solid-js";

export function routeData() {
  return { name: "Jane" };
}

export default function Index() {
  const data = useRouteData<ReturnType<typeof routeData>>();

  return <div>Welcome to SolidStart, {data().name}!</div>;
}
```

And this will render "Welcome to SolidStart, Jane!" In reality, `routeData` will be more complex: for example, it could be checking if a user is authenticated.

<Aside type="advanced" title="How this looks without file system routing" collapsible>

If you have used Solid App Router in a Solid app before, you may notice that the exported component and route data map closely to the properties of the `<Route />` component exported by `@solidjs/router`. This is no coincidence! If we were to write these routes without file system-based routing, our handwritten routes could use the same files and use the default-exported component and `routeData` functions as arguments to their `<Route />` components. You can even begin to write your routes from right within `root.tsx` before you decide to use the file-system routing.

```tsx
// @refresh reload
import { Suspense } from "solid-js";
import {
  Body,
  ErrorBoundary,
  FileRoutes,
  Head,
  Html,
  Meta,
  Routes,
  Scripts,
  Title,
} from "solid-start";

import { HttpStatusCode } from "solid-start/server";

function NotFound() {
  return (
    <main>
      <Title>Not Found</Title>
      <HttpStatusCode code={404} />
      <h1>Page Not Found</h1>
    </main>
  );
}

function Home() {
  return (
    <main>
      <Title>Home</Title>
      <h1>Home</h1>
    </main>
  );
}

export default function Root() {
  return (
    <Html lang="en">
      <Head>
        <Meta charset="utf-8" />
        <Meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>
      <Body>
        <Suspense>
          <ErrorBoundary>
            <a href="/">Home</a>
            <a href="/about">About</a>
            <Routes>
              <Route path="/" component={Home} />
              <Route path="*404" component={NotFound} />
            </Routes>
          </ErrorBoundary>
        </Suspense>
        <Scripts />
      </Body>
    </Html>
  );
}
```

</Aside>

## Nested route relationships

## Navigating between routes

While the user can enter your app from any URL that your app serves, once they are using your app, you can provide them a user experience that is designed. You need a way for the user to travel between your pages. As with any website, you can use `a` tags to add links between pages in your app. Nothing special! Lets look at an example,

```tsx

```

- How to link between pages (`a` tags, `Link`, `NavLink`)

## Redirecting

- The primary way of redirecting from a route to another is to use the `<Navigate />` component in the JSX. For example, if you want to redirect to the home page, you can use the following code.

  - **Server**: When we get a request for this page, we will rend a [`308 (Redirect)`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308) response with `Location` header set to the home page. The browser will then do its normal redirect routine. This also helps crawlers to understand that the page should be redirected.
  - **Client**: When you navigate to this page from another page in the site, we will immediately navigate to the home page.

```tsx filename="maths.ts"
export default function InactivePage() {
  return <Navigate to="/" />;
}
```

## Dynamic routes

In some cases, it would be horribly inefficient to create each route manually. When you are dealing with dynamic content, it only makes sense to use dynamic routes!

### Route parameters

In solid-start, route parameters are defined in the file name. The most basic type of route parameter is enclosed in brackets, like `[id].tsx`. parameters acts as a placeholder for any string. There can be multiple parameters for a single file, but you should ensure there is a delimiter between those parameters.

```ts
src/
├── routes/
│ ├── @[username]/
│ │ ├── index.tsx
│ │ ├── [post].tsx
```

### Catch-all routes

For routes, any subpath invalidates that route (with the noatable exception of folders). This behavior is often what we want, but not always. `/sometimes/nesting/forever/and/ever/is/ok`. For this, solid-start offers catch-all routes.

Catch-all routes are defined like `[...id].tsx`. A common use of catch-all routes is a 404 page. You want the route to apply everywhere so you define the catch-all route at the root, and if nothing more specific matches, the 404 route will.

### Accessing route parameters

Naturally, there is little use to dynamic routes if there is no way to provide dynamic content in response. To do so, you need to have a way to access the contents of each parameter.

Solid-app-router exports `useParams()`, a function that retrieves a reactive, store-like object that holds the route's parameters and their values.

```tsx
import { useParams } from "solid-app-router";

const params = useParams();

return <p>username: {params.username}</p>;
```

- routeData, accessing parent route data
  - Throwing in route data
- Search query params (not sure yet optimal API for this)
- Instructions for creating basic pages
- Nested routes (e.g., `auth.tsx` vs `auth/login.tsx`)
  - Talk about using route data function in parent route

## Status codes, headers, and other parts of the response

HTTP responses from the server don't just include the HTML body! SolidStart handles status codes and headers automatically, but gives you a few different ways to change the default values for these if necessary. [**Note:** mechanism for handling this is WIP, update when ready]

## Manually defining routes

- Mixing file based routes and `solid-app-router` routes
- Why you would want to do this

### Opting out of file system routing

- Opting out of file system-based routing
