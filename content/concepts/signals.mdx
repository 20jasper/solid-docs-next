import { Aside } from "~/components/configurable/Aside";

# Signals

At the heart of Solid's reactivity system are signals. 
Signals serve as a reactive variable that tell other parts of an application when to refresh.
When the value of a signal changes, the parts of your application that depend on that signal are automatically updated.

Signals eliminate the need to re-render an entire component function, focusing instead on updating only the changed aspects of the component. 
Furthermore, this adaptability of signals extend beyond component functions, providing them with the ability to be used in other areas of an application. 

## Creating a signal

To create a signal, import the `createSignal` primitive from Solid:

```js
import { createSignal } from "solid-js";
```

Once called, this function returns a pair of values: **getter** function responsible for _reading _ the current value of the signal, and a **setter ** function, designed to _write_ the signal's value:

```jsx
const [count, setCount] = createSignal(0);
```

In this example, `count` is the getter and `setCount`  is the setter function.

<Aside>
  The syntax using `[` and `]` is called [array destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment). 
  This lets you extract values from the array. 
  Specifically, in the context of `createSignal`, there are two items being returned: the getter (first), and the setter (second).
</Aside>

The ability of signals to handle most data type, along with components not owning state, lets you use signals anywhere in your application. 
This eliminates the need for any additional third-party state management libraries.

## Accessing values

To retrieve the value of a signal, you need to call the getter function:

```jsx
console.log(count()) // output: 0
```

When a signal is called within a [tracking scope](/essentials/intro-to-reactivity#tracking), it forms a dependent between the signal and the wrapping function. 
If the value of the signal changes, it notifies its dependencies of this change. 
As a result, anything that is subscribed to this signal through accessing it in a tracking scope, will be called again. 
This ensures that anything dependent on this signal will always be in sync with the state represented by these signals.

<Aside>
  A tracking scope is typically created by [`createEffect`](/reference/createEffect)  or [`createMemo`](/reference/createMemo), which are other Solid primitives. 
  Both functions subscribe to the signals accessed within them, establishing a dependency relationship.

  When a signal within this scope changes its value, these dependencies are identified, and the computations (such as Solid's effects or memos) relying on them are triggered to update.
</Aside>

## Updating values

To update a signal's value, you call the setter function returned by `createSignal`:

```jsx
setCount(count()+1)

console.log(count()) // output: 1
```

Signals are able to maintain a list of their dependents. 
[Effects](/essentials/effects) and [memos](/essentials/memos) subscribe to signals, thereby establishing a *dependency* on them.
This built-in dependency mechanism guarantees that whenever the signal's value changes, all associated functions are automatically notified and updated accordingly.

```jsx
function Counter() {
  const [count, setCount] = createSignal(0);
  
  // logs initial value of count
  console.log(count()) // result: 0
  
  // creates a reactive value `double` that is always twice the value of `count`
  const double = createMemo(() => count() * 2);
  
  return (
    <div>
      <p>Count: {count()}</p>
      <p>Double: {double()}</p>
      <button onClick={() => setCount(count() + 1)}>Increment</button>
    </div>
  );
}

export default Counter;
```

In this example, `createSignal` initializes a reactive state variable `count` and sets its initial value to `0` .

In the top-level code, which includes the `console.log` statement, execution happens only **once** â€” when the component is initially rendered.
 Components in Solid **do not** automatically trigger updates.
As a result, the initial value of `count`, which is `0`, will be logged to the console during the initial component rendering, regardless of any subsequent changes to the `count` value.

In contrast, `double` is initialized using `createMemo`, a Solid primitive that establishes a reactive computed value that depends on the `count` signal.
Unlike the `console.log` statement, `createMemo` ensures that `double` tracks the changes in `count`. 
Consequently, whenever `count` is updated, `double` automatically recalculates its value and displays the updated value as a result.

To learn more about how to use Signals in your application, visit our [state management guide](/guides/state-management).