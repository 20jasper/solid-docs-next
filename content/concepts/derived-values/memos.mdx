import { Aside } from "~/components/configurable/Aside";

# Memos

Memos in Solid serve a dual purpose - they are both a signal *and* a computation, primarily being used for memoizing derived state. 
Memos allow you to create a derived value that recalculates only when its dependencies change. 
By doing so, they offer a way to use these derived values, cache the results of expensive or frequently accessed computations, and minimize unnecessary work. 

Through the combination of observing changes in their dependencies (similar to an effect) and exposing a *read-only* reactive value (like a signal), memos can adapt well to changes to reduce unnecessary re-renders.

## Using memos

Creating a memo involves calling the `createMemo` function and passing a function as its argument.
The memo will then define the derived value or computations you wish to memoize. 
When called, `createMemo` will return a **getter** function that reads the current value of the memo:

```jsx
import { createMemo, createSignal } from 'solid-js';

const [count, setCount] = createSignal(0);

const isEven = createMemo(() => count() % 2 === 0);

console.log(isEven()) // true

setCount(3);
console.log(isEven()) // false
```

In this example, `isEven` serves as the getter function that evaluates whether the value of the `count` signal is even.
Whenever `count` undergoes a change, `isEven` will automatically re-run.

### Advantages of using memos

While it is possible to use regular functions to mimic the behavior of a memo, `createMemo` offers distinct advantages:

- Unlike a [basic derived signal](/concepts/derived-values/derived-signals) or [effects](/concepts/effects), memos are optimized to execute only _once_ for each change in their dependencies.
This significantly reduces computational overhead.

- Where a signal is updated once but *accessed* multiple times, the memoized function will only execute once and will **cache** its results.

- If a cached value remains unchanged despite a change in its dependencies (as determined by `===`), it won't trigger subsequent updates. 
For example, calling `setCount(0)` and then `setCount(2)` will cause the `isEven` memo to recompute both times, but because both evaluations are `true`, the second update will not cause any further updates in components relying on `isEven()`.

- With a memo's ability to automatically track dependencies, any signal or memo accessed within its function is **tracked**. 
As a result, the memo will re-evaluate automatically when these dependencies change, removing the need for a dependency array.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=ACJTLvgPnReEQszYSUwoLw&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=ACJTLvgPnReEQszYSUwoLw)

## Memo vs. effect

Both memos and effects are important when managing reactive computations and side effects.
They, however, serve different purposes and each have their own unique behaviors.

| | Memos  | Effects   |
|-|--------|-----------|
| Return value  | Yes - returns a getter for the result of the computation or derived state. | Does not return a value but executes a block of code in response to changes. |
| Caches results | Yes | No |
| Behavior | Function argument should be pure without reactive side effects. | Function argument can cause side effects like UI updates or data fetches. |
| Dependency tracking. | Yes | Yes |
| Example use cases | Transforming data structures, computing aggregated values, derived state, or other expensive computations. | UI updates, network requests, or external integrations. |

## Best practices

When working with memos, it is recommended that you leave them "pure". 
This means you should not modify other signals because it can lead to unexpected behaviors and make the code harder to maintain. 

```jsx
import { createSignal, createMemo } from 'solid-js';

const [count, setCount] = createSignal(0);
const isEven = createMemo(() => count() % 2 === 0); // example of a pure function
```

Since memos are expected to be pure functions, their outputs should solely depend on their inputs without side effects. 
When you add a side effect, the reactivity chain is complicated which potentially introduces infinite update loops:

```jsx
import { createSignal, createMemo } from 'solid-js';

const [count, setCount] = createSignal(0);
const [message, setMessage] = createSignal("");

const badMemo = createMemo(() => {
    if (count() > 10) {
        setMessage("Count is too high!"); // this is a reactive side effect

    }
    return count() % 2 === 0;
});
```

In cases where another part of the application reacts to changes in the signal, such as `message()` above, any further updates or side effects can be triggered.
This can complicate the flow of data and cause a possible infinite update loop.
You can rewrite `badMemo` above using a `createEffect` to handle the side effects more appropriately:

```jsx
import { createSignal, createMemo, createEffect } from 'solid-js';

const [count, setCount] = createSignal(0);
const [message, setMessage] = createSignal("");

const isEven = createMemo(() => count() % 2 === 0);

createEffect(() => {
    if (count() > 10) {
        setMessage("Count is too high!");
    }
});
```

In this updated approach, the `isEven` memo will compute based on whether `count` is even *without* side effects.
However, it is better practice to convert any unnecessary effects into memos.
This helps minimize unnecessary updates in other parts of the application, because it lets Solid understand the reactive dependencies and thus optimize evaluation order.
And, generally speaking, opting for memos is the recommended approach over the use of effects:

```jsx
const message = createMemo(() => {
  if (count() > 10) {
    return "Count is too high!";
  } else {
    return "";
  }
});

```

The clear separation of concerns - keeping the computational logic in memos and the side effects in effects - keeps an application's reactivity straightforward and manageable, which reduces the risk of any unintended behaviors.

<Aside>
While memo's are generally best practice, effects still have their place.
For example, in situations where external side effects are required (eg. DOM updates) using the `createEffect` function *should* be used over a memo.
</Aside>