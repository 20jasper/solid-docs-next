import { Aside } from "~/components/configurable/Aside"

# Intro to Reactivity

**Note**: While this guide is useful for understanding reactive systems, it does use some Solid-specific terminology.

Reactivity, at its core, provides the groundwork to power interactivity in dynamic applications.
This programming paradigm is when systems automatically respond to changes in data or state, ensuring that the application's interface stays consistent with its underlying data.
With Solid, reactivity is the basis of its design.

## Importance of reactivity

1. **Automatic UI updates**: Reactivity ensures that as data changes, the user interface is automatically updated to reflect those changes.

2. **Simplified code**: By removing the need for manual DOM updates or UI refreshes, reactivity reduces the need for manual interventions.
   This synchronizes the state and the UI, leading to more straightforward and maintainable code.

3. **Consistent user experience**: With the UI always being in sync with the underlying data, users get a consistent and expected response to their actions.

4. **Scalability**: As applications grow, managing state and UI can become complex. Reactivity abstracts this complexity, ensuring that even large-scale applications remain manageable.

```jsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	return (
		<button type="button" onClick={increment}>
			{count()} {/* The UI is automatically updated when `count()` changes. */}
		</button>
	)
}
```

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=cry9JT4nroFQ4rRxzOpvCg&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=cry9JT4nroFQ4rRxzOpvCg)

## Reactive principles

When delving into the world of reactivity, you'll encounter a few foundational principles.

### Signals

Signals serve as core elements in reactive systems, playing a pivotal role in data management and system responsiveness.

A signal can be visualized as a container for data.
It not only holds the data, but provides ways for accessing and modifying its' value.

Signals contain a dual capability that makes them both readable and writeable:

- **Getter**:
  The function responsible for accessing the current value of the signal.
  When various components or parts of an application need to "read" or retrieve the data stored in a signal, they use a getter.
- **Setter**:
  The tool that permits the changing of the signal's value.
  Any change to the value within a signal, made possible by the setter function, can create reactive updates in other connected parts of the system.
  This ensures that the system remains responsive and up-to-date with the latest data changes.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=lseAEjGlKLslaVsTlfej_g&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=lseAEjGlKLslaVsTlfej_g)

### Listeners

Listeners (such as effects and memos) can be thought of as automated responders.
They are closely tied to signals and are set into motion whenever there is a change in the signals they observe.
Their primary role is to ensure that any changes in signals are appropriately reflected throughout the application to maintain its' reactivity.

The nature of effects revolves around two functionalities:

- **Observation**: At the heart of every effect is its ability to "observe" or watch signals.
  This keeps effects primed to detect changes in the signals they are tied to.
- **Activation**: Upon recognizing a change in an observed signal, the effect will promptly be called.
  This can involve tasks like updating the UI, triggering a process, or calling external functions.
  Through this activation, effects ensure that the system's reactivity is both immediate and relevant.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=yri1GCRyso7UppNS8QyWyw&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=yri1GCRyso7UppNS8QyWyw)

#### Dependency tracking

An essential part of managing effects in a reactive system is _dependency tracking_.  
This process involves keeping track of the specific signals that an effect relies on.
By doing this, the system can determine when the effect needs to be re-triggered or updated based on changes in its dependent signals.

This tracking is important when maintaining a fine-grained reactive system.
This level of precision in tracking dependencies helps in prevent unnecessary re-executions, contributing to a more reliable reactive system.

## Building a reactive system

Reactive systems are designed around the principle of data-driven reactivity.
This is when signals, effects, and memos maintain a relationship.
This relationship ensures a seamless propagation of data changes throughout the system, guaranteeing its responsiveness and real-time updates.

### Initialization

The start of a reactive system begins with the setup of signals.
During this phase, signals are initialized with their respective starting values.
These initialized signals serve as the primary data sources that the rest of the system will rely on.

### Subscription

Once signals are established, the next step involves the effects indicating their dependencies.
In this phase, effects "subscribe" to specific signals, marking their interest and establishing a link.
This subscription keeps the effects aware of any changes to the signals they are tied to.

### Notification

During the notification phase, any update in a signal's value sets off a chain reaction.
The altered signal proactively notifies all its subscribed effects about the modification.
Upon receiving this notification, these effects then update or activate as necessary to keep the system's state current and synchronized with the latest data changes.

## Tracking

At its core, tracking is fundamentally about managing subscriptions in a reactive system.
When a signal undergoes a change, all the listeners subscribed to it are re-run, if needed; this ensures the propogation of changes throughout the application's components.

## Synchronous vs. asynchronous

Reactivity in systems can manifest primarily in two ways: synchronous and asynchronous.
The choice between these often depends on the requirements of the system and the nature of the tasks involved.

### Synchronous reactivity

[Synchronous](https://developer.mozilla.org/en-US/docs/Glossary/Synchronous) reactivity operates in a direct and linear fashion.
When a signal changes, its corresponding effects are immediately updated in an ordered manner.
This form of reactivity creates a relationship between a signal's change and the system's response, guaranteeing that the system remains updated with the most recent data.

### Asynchronous reactivity

[Asynchronous](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous) reactivity can improve performance in some cases.
Unlike its synchronous counterpart, updates to effects are not instantaneous.
Instead, they may be delayed, or they could wait for the completion of an external event or task.

This approach is useful in scenarios where an effect depends on multiple signals and when updating one signal before another may result a data inconsistency.
In such a scenario, [`batch`](/reference/batch) can be used to delay triggering effects so the effect runs after both signals have been updated.

## State management

At the core, signals serve as containers for state by providing a means for updating and manipulating data.
This makes changing state easier by simplifying interactions and modifications.

When state changes, it triggers a cascade of reactive updates throughout the system.
Components or functions that are subscribed to them are promptly notified of these changes and able to respond accordingly.
This keeps the user interface and other system components synchronized with the underlying data.

### Key concepts

- Subscriptions are initaited when a piece of state is accessed through a signal.
  This interaction leads to the accessor _subscribing_ to the signal, establishing a dynamic connection.
  Every interaction between the signal and its accessor guarantees that the associated listeners are re-run when the signal changes.
- Interactions with a signal outside of a reactive scope will not initiate tracking, due to the absence of a subscriber, thus limiting the scope of reactivity.
- The reactive system is built on the interplay between elements that can change (signals) and those that can be updated, listeners.
  The principles of tracking are not limited to these elements, however, but also extend to props and other elements.
- A signal is unique since it operates independently and is reliable; it can be viewed as a standalone element in the reactivity graph.

Using Solid:

```tsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	createEffect(() => {
		console.log("My effect says " + count())
	})
	/* The `createEffect` acts as a listener and the `count()` (the signal) is now tracked as a subscription of this effect. This code will run *only* when `count()` changes. */

	console.log(count()) // In this case,`count()` is *not* in a tracking scope. This means it will not re-run when `count()` changes.

	return (
		<button type="button" onClick={increment}>
			{count()}
			{/* JSX is a tracking scope because it wraps expressions in effects behind the scenes. 
      Because of this, the code will register `count()` as a subscription when it is called. */}
		</button>
	)
}
```

If you want to dive deeper, visit the [guide on fine-grained reactivity](/advanced/fine-grained-reactivity).
