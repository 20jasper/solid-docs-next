import { Aside } from "~/components/configurable/Aside"

# Intro to Reactivity

**Note**: While this guide is useful for understanding reactive systems, it does use some Solid-specific terminology.

Reactivity provides the groundwork to power interactivity in dynamic applications.
This programming paradigm refers to a system's ability to respond to changes in data or state automatically.
With Solid, reactivity is the basis of its design, ensuring application's stay up-to-date with its underlying data.

## Importance of reactivity

1. **Automatic UI updates**: Reactivity ensures that as data changes, the user interface(UI) is automatically updated to reflect those changes.

2. **Simplified code**: By removing the need for manual DOM updates or UI refreshes, reactivity reduces the need for manual interventions.
   This synchronizes the state and the UI, leading to more straightforward and maintainable code.

3. **Consistent user experience**: With the UI being in sync with the underlying data, users get a consistent and expected response to their actions.

4. **Scalability**: As applications grow, managing state and UI can become complex. Reactivity abstracts this complexity, ensuring that even large-scale applications remain manageable.

```jsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	return (
		<button type="button" onClick={increment}>
			{count()} {/* The UI is automatically updated when `count()` changes. */}
		</button>
	)
}
```

This `Counter` function sets up a button that, when clicked, calls the `increment` function to increase the `count` by one. 
This updates just the number displayed *without* refreshing the entire component.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=cry9JT4nroFQ4rRxzOpvCg&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=cry9JT4nroFQ4rRxzOpvCg)

## Reactive principles

### Signals

Signals serve as core elements in reactive systems, playing a pivotal role in data management and system responsiveness.
These signals are both readable and writeable, meaning they can be accessed and modified.
This is made possible through the use of getters and setters.

```jsx
const [count, setCount] = createSignal(0)
  //     ^ getter  ^ setter
```

- **Getter**:
  A function responsible for accessing the current value of the signal.
	You call a getter to access the data stored in a signal within a component.
- **Setter**:
  The function used to modify a signal's value.
  To trigger reactive updates across an application, you call a setter to update the value of a signal.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=lseAEjGlKLslaVsTlfej_g&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=lseAEjGlKLslaVsTlfej_g)

#### State management

Signals serve as containers for state by providing a way to update and change data.
This simplifies accessing and changing state.

When state changes, a cascade of reactive updates is triggered throughout the system.
Components or functions that are subscribed to signals are promptly notified of these changes and able to respond accordingly.
This keeps the user interface and other system components in sync with the underlying data.

**Note:** With Solid, components are automatically subscribed to signals when they are accessed within the component's scope.
What this means is that within the JSX of a component, any signal that is accessed will be tracked and subscribed to.
However, if a signal is accessed outside of the JSX, it will not be tracked and therefore will not trigger a reactive update when it changes.

```jsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	console.log(count()) // In this case,`count()` is *not* in a tracking scope. Therefore, it will not re-run when `count()` changes.

	return (
		<button type="button" onClick={increment}>
			{count()}
			{/* JSX creates a tracking scope because it wraps expressions in effects behind the scenes. This will provide a subscription to `count()` when called. */}
		</button>
	)
}
```

### Subscribers

Subscribers can be thought of as automated responders.
Their primary role is track any changes in signals and then update the application to maintain its' reactivity.
If a signal is accessed outside of the scope of a subscriber, it will not be tracked and therefore will not trigger a reactive update when it changes.

Subscribers work based on two main actions:

- **Observation**: At their core, subscribers observe signals.
This keeps the subscriber primed to pick up on any changes to the signal they are tracking.
- **Activation**: When a subscriber notices a change in the signal it is tracking, it responds.
This can involve tasks like updating the UI, triggering a process, or calling external functions.

```jsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	createEffect(() => {
		console.log(count())
	})
	/* The `createEffect` acts as a subscriber and `count()` (the signal) is now tracked. This code will run *only* when `count()` changes. */

	return (
		<button type="button" onClick={increment}>
			{count()}
		</button>
	)
}
```

## Building a reactive system

Reactive systems are designed around the principle of data-driven reactivity.
This means that the system's reactivity is driven by the data it is built on.
Through this, the system is able to respond to changes in data, ensuring that the UI and other components are always up-to-date.

**1. Initialization**

A reactive system begins with the setup of signals.
During this phase, signals are initialized with their respective starting values.
These will serve as the primary data sources that the rest of the system will rely on.

**2. Subscription**

Once signals are initialized, the next step is to establish subscriptions.
This is done by linking subscribers to the signals they need to track, known as dependencies.
Subscribers are then able to track, or follow, any changes to the signals they are subscribed to.

<Aside>
	Tracking is the process of monitoring changes to signals.
	When a signal is tracked, it is added to a list of dependencies that the subscriber is subscribed to.
	This ensures that the subscriber is notified when the signal changes.
</Aside>

**3. Notification**

When a signal changes, the subscribers are notified.
This ensures that the system is kept up-to-date with the latest data changes.
Once a subscriber is notified, it can then take the necessary actions to keep the application's data current with the latest data changes.

## Synchronous vs. asynchronous

Reactive systems are designed to respond to changes in data.
These responses can be immediate or delayed, depending on the nature of the system.
Often, the choice between these two depends on the requirements of the application and the nature of the tasks involved.
This is where synchronous and asynchronous reactivity come into play.

### Synchronous reactivity

[Synchronous](https://developer.mozilla.org/en-US/docs/Glossary/Synchronous) reactivity is Solid's default reactivity model.
This is when a system responds to changes in a direct and linear fashion.
When a signal changes, the corresponding subscribers are immediately updated in an ordered manner.

When synchronous reactivity is used, the system is able to respond to changes in a predictable manner.
This is useful in scenarios where the order of updates is important.
For example, if a subscriber depends on another signal, it is important that the subscriber is updated after the signal it depends on.

```jsx
	const [count, setCount] = createSignal(0)
	const [double, setDouble] = createSignal(0)

	createEffect(() => {
		setDouble(count() * 2)
	})
	// The `double` signal will always be updated after `count` due to synchronous reactivity.
	// This ensures that `double` is always up-to-date with the latest value of `count`.
```

### Asynchronous reactivity

[Asynchronous](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous) reactivity is when a system responds to changes in a delayed or non-linear fashion.
When a signal changes, the corresponding subscribers are not immediately updated.
Instead, the system waits for a specific event or task to complete before updating the subscribers.

This is important in scenarios where subscribers depend on multiple signals.
In these cases, updating one signal before another could result in data inconsistency.
For example, if a subscriber depends on two signals, it is important that the subscriber is updated after both signals have been updated.
Rather, the system waits for both signals to be updated before updating the subscriber.

**Note:** When asynchronous reactivity is present, it is important to ensure that the system is able to handle the delay in updates.
[`batch`](/reference/batch) can be used to delay an update so the subscriber runs after each signal has been updated.

## Key concepts

- Signals are the core elements of a reactive system.
  They are responsible for storing and managing data.
- Signals are both readable and writeable because of getters and setters.
- Subscribers are automated responders that track changes in signals and update the system accordingly.
- Signals and subscribers work together to ensure that the system is kept up-to-date with the latest data changes.
- A reactive system is built on the principles of data-driven reactivity.
  This means that the system's reactivity is driven by the data it is built on.
- Reactive systems can be synchronous or asynchronous.

If you want to dive deeper, visit the [guide on fine-grained reactivity](/advanced/fine-grained-reactivity).
