import { Aside } from "~/components/configurable/Aside"

# Intro to Reactivity

**Note**: While this guide is useful for understanding reactive systems, it does use some Solid-specific terminology.

Reactivity provides the groundwork to power interactivity in dynamic applications.
This programming paradigm refers to a system's ability to respond to changes in data or state automatically.
With Solid, reactivity is the basis of its design, ensuring application's stay up-to-date with its underlying data.

## Importance of reactivity

1. **Automatic UI updates**: Reactivity ensures that as data changes, the user interface(UI) is automatically updated to reflect those changes.

2. **Simplified code**: By removing the need for manual DOM updates or UI refreshes, reactivity reduces the need for manual interventions.
   This synchronizes the state and the UI, leading to more straightforward and maintainable code.

3. **Consistent user experience**: With the UI being in sync with the underlying data, users get a consistent and expected response to their actions.

4. **Scalability**: As applications grow, managing state and UI can become complex. Reactivity abstracts this complexity, ensuring that even large-scale applications remain manageable.

```jsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	return (
		<button type="button" onClick={increment}>
			{count()} {/* The UI is automatically updated when `count()` changes. */}
		</button>
	)
}
```

This `Counter` function sets up a button that, when clicked, calls the `increment` function to increase the `count` by one. 
This updates just the number displayed *without* refreshing the entire component.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=cry9JT4nroFQ4rRxzOpvCg&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=cry9JT4nroFQ4rRxzOpvCg)

## Reactive principles

### Signals

Signals serve as core elements in reactive systems, playing a pivotal role in data management and system responsiveness.

Signals are both readable and writeable through the use of getters and setters.

- **Getter**:
  The function responsible for accessing the current value of the signal.
	To access the data in a signal within a component, a getter function is called.
- **Setter**:
  The function used to modify a signal's value.
  Changing a signal's value with its setter function can trigger reactive updates across different parts of the system that are dependent on that signal.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=lseAEjGlKLslaVsTlfej_g&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=lseAEjGlKLslaVsTlfej_g)

#### State management

Signals serve as containers for state by providing a means for updating and manipulating data.
This simplifies accessing and changing state.

When state changes, a cascade of reactive updates is triggered throughout the system.
Components or functions that are subscribed to signals are promptly notified of these changes and able to respond accordingly.
This keeps the user interface and other system components in sync with the underlying data.

### Subscribers

Subscribers can be thought of as automated responders.
Their primary role is track any changes in signals and then update the application to maintain its' reactivity.

Subscribers work based on two main actions:

- **Observation**: At their core, subscribers observe signals.
This keeps the subscriber primed to pick up on any changes to the signal they are tracking.
- **Activation**: When a subscriber notices a change in the signal it is tracking, it responds.
This can involve tasks like updating the UI, triggering a process, or calling external functions.

## Building a reactive system

Reactive systems are designed around the principle of data-driven reactivity.
This is when signals, effects, and memos maintain a relationship.
This relationship ensures a seamless propagation of data changes throughout the system, guaranteeing its responsiveness and real-time updates.

**1. Initialization**

A reactive system begins with the setup of signals.
During this phase, signals are initialized with their respective starting values.
These signals will serve as the primary data sources that the rest of the system will rely on.

**2. Subscription**

Once signals are established, the next step involves linking subscribers to their dependencies.
This provides subscribers the ability to track changes to the signals they can now access.

**3. Notification**

Any update in a signal's value sets off a chain reaction.
The updated signal notifies all its subscribers about this change.
When a subscriber receives an update, the necessary actions are taken to keep the application's data current with the latest data changes.

## Tracking

Tracking is fundamentally about managing subscriptions in a reactive system.
When a signal undergoes a change, all the subscribers are re-run, if needed; this ensures updates throughout the application's components, if required.

## Synchronous vs. asynchronous

Reactivity in systems can happen in two ways: synchronously and asynchronously.
The choice between these often depends on the requirements of the application and the nature of the tasks involved.

### Synchronous reactivity

[Synchronous](https://developer.mozilla.org/en-US/docs/Glossary/Synchronous) reactivity operates in a direct and linear fashion.
When a signal changes, the corresponding subscribers are immediately updated in an ordered manner.
This creates a relationship between the udpated signal and the application's response keeping the system updated with the most recent data.

### Asynchronous reactivity

[Asynchronous](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous) reactivity can improve performance in some cases.
Unlike synchronicity, updates to effects are not instantaneous.
They may be delayed or they could wait for the completion of an external event or task.

This is useful in scenarios where an subscribers depend on multiple signals and updating one signal before another could result in data inconsistency.
In these scenarios, [`batch`](/reference/batch) can be used to delay an update so the subscriber runs after each signal has been updated.

## Key concepts

- Subscriptions are initaited when a piece of state is accessed through a signal.
  This interaction leads to the accessor _subscribing_ to the signal, establishing a dynamic connection.
- Every interaction between the signal and its accessor guarantees that the associated subscriber is re-run when the signal changes.
- Interactions with a signal outside of a reactive scope will not initiate tracking, due to the absence of a subscriber, thus limiting the scope of reactivity.
- A reactive system is built on the interplay between elements that can change (signals) and their subscribers.
The principles of tracking are not limited to these elements, however, but also extend to props and other elements.
- A signal is unique since it operates independently and is reliable; it can be viewed as a standalone element in the reactivity graph.

Using Solid:

```tsx
function Counter() {
	const [count, setCount] = createSignal(0)
	const increment = () => setCount(count() + 1)

	createEffect(() => {
		console.log("My effect says " + count())
	})
	/* The `createEffect` acts as a subscriber and `count()` (the signal) is now tracked. This code will run *only* when `count()` changes. */

	console.log(count()) // In this case,`count()` is *not* in a tracking scope. Therefore, it will not re-run when `count()` changes.

	return (
		<button type="button" onClick={increment}>
			{count()}
			{/* JSX creates a tracking scope because it wraps expressions in effects behind the scenes. This will provide a subscription to `count()` when called. */}
		</button>
	)
}
```

If you want to dive deeper, visit the [guide on fine-grained reactivity](/advanced/fine-grained-reactivity).
