import TabsCodeBlocks from "~/components/configurable/TabsCodeBlocks"
import { CodeTabs } from "~/components/Tabs"

# Context

Context provides a way to pass data through the component tree without having to pass props down manually at every level.

## When to use context

If you only want to avoid passing some props through many levels, component composition is often a simpler solution than context.
Passing props through intermediate elements makes components more difficult to reuse, and makes it harder to see where props are coming from.
Since the nature of Solid makes it easy to compose components without [prop drilling](/concepts/components/props#prop-drilling), [signals](/concepts/signals) or [stores](/concepts/stores) are often a better solution for managing state.

Context is designed to share data that can be considered "global", such as the current authenticated user, theme, or preferred language.
It offers a way to access values more efficiently instead of passing props through many levels of the component tree.
When there may be information required at some levels of the component tree, but not all, context can be used to avoid passing props through intermediate elements.

## Creating context

Context is created using the [`createContext`](/reference/createContext) function:

```jsx
import { createContext } from "solid-js"

const MyContext = createContext()
```

`createContext` can take in a default value as an argument.
If a component does not have a `Provider` component in its ancestry, this default value is given to the `createContext` function.

To provide context to a component tree, you need to use the `Provider` method on the context object.
This is done by wrapping the component tree in a `Provider` component:

```jsx
import { createContext } from "solid-js";

const MyContext = createContext()

export const Provider(props) {
	return (
		<MyContext.Provider>
			{props.children}
		</MyContext.Provider>
	)
}
```

## Providing context to children

To pass a value to the `Provider`, you use the `value` prop which can take in any value, including [signals](#updating-context-values).
Once a value is passed to the `Provider`, it is available to all components that are descendants of the `Provider`.

When passing a single value, it can be directly passed to the `value` prop:

```jsx
import { createContext, useContext } from "solid-js"

const MyContext = createContext("initial")

const Provider = (props) => (
	<MyContext.Provider value="new value">{props.children}</MyContext.Provider>
)
```

However, if you need to access multiple values, they must be passed as an object literal, or using double curly braces (`{{ }}`):

```jsx
import { createContext, createSignal } from "solid-js"

const MyContext = createContext("default value")

export const Provider() {
	const stringVal = "new value"
	const numberVal = 3;
	const objVal = {
		foo: "bar",
		obj: true,
		};

	return (
		<MyContext.Provider value={{
			stringVal,
			numberVal,
			objVal
		}}>
			{props.children}
		</MyContext.Provider>
	)
}
```

## Consuming context

Once the values are available to all the components in the context's component tree, they can be accessed using the [`useContext`](/references/useContext) utility.
`useContext` takes in the context object and returns the value(s) passed to the `Provider`:

```jsx
import { createContext, useContext } from "solid-js"

const MyContext = createContext()

const Provider = (props) => (
	<MyContext.Provider value="new value">{props.children}</MyContext.Provider>
)

const Child = () => {
	const value = useContext(Context)
	return <>{value}</>
}

export const App = () => (
	<Provider>
		<Child /> {/* "new value" */}
	</Provider>
)
```

When your context contains multiple values, you can destructure the values from `useContext`.
This allows you to access the values you need without having to access the entire context object:

```jsx
import { createContext, useContext, createSignal } from "solid-js"

const MyContext = createContext()

const Provider = (props) => {
	const stringVal = "new value"
	const numberVal = 3
	const objVal = {
		foo: "bar",
		obj: true,
	}
	const [signal, setSignal] = createSignal("example signal")
	return (
		<MyContext.Provider
			value={{
				stringVal,
				numberVal,
				objVal,
			}}
		>
			{props.children}
		</MyContext.Provider>
	)
}

const Child = () => {
	const { stringVal, numberVal } = useContext(MyContext)
	return (
		<>
			<h1>{stringVal}</h1>
			<span>{numberVal}</span>
		</>
	)
}

export const App = () => (
	<Provider>
		<Child />
	</Provider>
)
```

## Updating context values

[Signals](/concepts/signals) offer a way to synchronize and manage data shared across your components using context.
You can pass a signal directly to the `value` prop of the `Provider` component, and any changes to the signal will be reflected in all components that consume the context.

		<TabsCodeBlocks>
					<div id="App.jsx">
						```jsx
	import Counter from "./counter";
	import { CounterProvider } from "./counter";

    export function App() {
    	return (
    		<CounterProvider count={1}>
    			<h1>Welcome to Counter App</h1>
    			<Nested />
    		</CounterProvider>
    	)
    }

```
			</div>

			<div id="Context.jsx">
						```jsx
import { createSignal, createContext, useContext } from "solid-js";

const CounterContext = createContext(); // create context

export function CounterProvider(props) { // create provider
  const [count, setCount] = createSignal(props.count || 0),
    counter = [
      count,
      {
        increment() {
          setCount(c => c + 1);
        },
        decrement() {
          setCount(c => c - 1);
        }
      }
    ];

return (
<CounterContext.Provider value={counter}>
{props.children}
</CounterContext.Provider>
);
}

export function useCounter() { return useContext(CounterContext); } // custum utility to access context
```

			</div>
			<div id="Child.jsx">
						```jsx
import { useCounter } from "./Context";

export function CounterProvider(props) {
  const [count, { increment, decrement }] = useCounter();
return (
  <>
    <div>{count()}</div>
    <button onClick={increment}>+</button>
    <button onClick={decrement}>-</button>
  </>
);
};
```
			</div>
					</TabsCodeBlocks>

This offers a way to manage state across your components without having to pass props through intermediate elements.

## Debugging with context

`createContext` takes in an _optional_ default value and it is possible it can return `undefined` if not provided.
When working with TypeScript, this can introduce type issues that make it difficult to determine why your component is not rendering as expected.

To solve this issue, a default value can be specified when creating a context object, or errors can be handled manually through the use of a custom `useMyContext` utility:

```jsx
import { createContext, useContext } from "solid-js";

const MyContext = createContext<string>();

function useMyContext() {
  const value = useContext(MyContext);
  if (value === undefined) {
    throw new Error("useMyContext must be used within a MyContext.Provider");
  }
  return value;
}

function Child() {
  const value = useMyContext();
  return <div>{value}</div>;
}
```
