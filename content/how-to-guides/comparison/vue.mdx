import {CodeTabs} from "~/components/Tabs";

<Title>Comparison with Vue</Title>

Solid is not particularly influenced by Vue design-wise, but they are comparable in approach. They both use Proxies in their Reactive system with read based auto-tracking. But that is where the similarities end. Vue's fine-grained dependency detection just feeds into a less fine-grained Virtual DOM and Component system whereas Solid keeps its granularity right down to its direct DOM updates.

Vue values easiness where Solid values transparency. Although Vue's direction with Vue 3 and the introduction of the composition API aligns more with the approach Solid takes. These libraries might align more over time depending on how they continue to evolve. Most of the examples and references to Vue in this section will be made in regards to the Composition API introduced in Vue 3.

## Template Components vs Function Components
In terms of frontend frameworks components serve as a way to split the UI into different reusable pieces of code, most applications and sites nowadays are mostly just trees of nested components.

### Vue
In Vue setting up components can be done in 2 ways either by using Templates or by using Render Functions. The most common way right now is through the use of Templates, like so:

```vue
<script lang="ts" setup>
import { ref } from "vue";

const count = ref(0);
</script>

<template>
  <button @click="count++">Count was pressed {{ count }} times</button>
</template>
```

If you are unfamiliar with it, this is the template syntax used with the composition API in Vue. HTML is used in the `<template></template>` tag and Javascript or Typescript is used in the `<script></script>` tag. There is a third tag used for styling called the `<style></style>` tag as well.

### Solid

Solid on the other hand makes use of only one kind of component, the function component. Unlike Vue, Solid doesn't have different syntaxes, it only has one. All components and pages in Solid are represented by function components. E.g:

```tsx
import { Component, createSignal } from "solid-js";

const App = () => {
  const [count, setCount] = createSignal(0);
  return (
    <div>
      <button onclick={() => setCount((previousValue) => previousValue + 1)}>
        You clicked me {count} times
      </button>
    </div>
  );
};

export default App;
```

This is what a function component looks like. Notice the major difference between this and the template syntax used by Vue. There are also some slight differences in the way variables are used in the HTML portion e.g a single curly bracket instead of two. The syntax to declare and mutate for stateful variables is also quite different, more on this later.

## Reactivity and Statefulness

In Vue there are 2 key functions that are used to declare and manage reactive and stateful values, `ref()` and `reactive()`, `ref()` being able to store primitives such as booleans, numbers, strings and objects as well, and `reactive()` only being able to store objects. Solid has similar functions to these namely `createSignal()` and `createStore()` respectively. In this part we will be discussing about their differences in syntax and update methods.


There is not much of a difference between the syntax of `ref()` and `createSignal()` or that of `reactive()` and `createStore()`, in fact, `reactive()` and `createStore()` are similar in syntax when accessing values but different when changing values e.g:
```js
// Vue 
const store = reactive({count:0})
function someFunc() {
  console.log(store.count) // accessing
  store.count = store.count+1 // setting
}

// Solid
const [store, setStore] = createStore({count:0})
function someFunc() {
  console.log(store.count) // accessing
  setStore(prev => prev = {...prev, count:prev.count + 1}) // setting
}
```
While on the other hand `ref()` and `createSignal()` are different in both setting and accessing their values, e.g:
```js
// Vue 
const count = ref(0)
function someFunc(){
  console.log(count.val) // accessing
  count.value = count.value + 1 // setting
}

// Solid
const [count, setCount] = createSignal(0)
function someFunc() {
  console.log(count()) // accessing
  setCount(prev => prev + 1) // setting
}
```
__Below is a more in-depth look at how the syntax might differ in a simple counter app__

### Vue

In Vue you can make use of the `ref()` and `reactive()` functions to handle state in a Vue component. In some cases `reactive()` can serve as a simple state management alternative instead of having to make use of VueX. Here's a quick snippet of what that might look like:

```js
// store.js
import { reactive } from "vue";

export const store = reactive({
  count: 0,
});
```
Above we created our store using the `reactive()` function.

```vue
<!-- ComponentA.vue -->
<script setup>
import { store } from "./store.js";

const unreactiveLocalValue = store.count;
//Note: this will not behave reactively
</script>

<template>
  <button @click="store.count + 1">add +1 to store.count</button>
</template>
```
Above is a component which has the store imported in order to change one of the values within the store.

```vue
<!-- ComponentB.vue -->
<script setup>
import { store } from "./store.js";

const unreactiveLocalValue = store.count;
//Note: this will not behave reactively
</script>

<template>From B: {{ store.count }}</template>
```
This is a seperate component which will display the value of the count even as it is changing.

You can also make use of other reactive state such as `ref()` and `computed()`.

```js
// store.js
import { ref } from "vue";

export const storeUsingRef = ref(0);
```

```vue
<!-- ComponentA.vue -->
<script setup>
import { storeUsingRef } from "./store.js";

//Note: to make use of ref() values in the script section you will have to use the .value property like so:
const reactiveLocalValue = storeUsingRef();
//This will behave reactively
</script>

<template>
  <button @click="storeUsingRef + 1">add +1 to store</button>
</template>
```

```vue
<!-- ComponentB.vue -->
<script setup>
import { storeUsingRef } from "./store.js";

//Note: to make use of ref() values in the script section you will have to use the .value property like so:
const reactiveLocalValue = storeUsingRef();
//This will behave reactively
</script>

<template>
  <h2>From B: {{ storeUsingRef }}</h2>
  <h2>From B: {{ localValue }}</h2>
</template>
```
Take note of the comments within the code and how reactivity changes when `reactive()` or `ref()` is used.

### Solid

In Solid we can do something similar by making use of the `createStore()` and the `createSignal()` primitives. Remember that `createStore()` only takes in objects as values, while `createSignal()` can take in booleans, objects, strings and numbers. Here's a quick example of what it might look like if you decide to use `createStore()` as a simple state management solution

```js
// store.js
import { createStore } from "solid-js/store";

export const [store, setStore] = createStore({ count: 0 });
```
Above we created a store using `createStore()` in Solid. 

```jsx
// Component A.jsx
import { setStore, store } from "./store";

const ComponentA = () => {
  const unreactiveLocalValue = store.count;
  //Note: this will not behave reactively

  return (
    <div>
      <button
        onclick={() => setStore((prev) => (prev = {...prev, count: prev.count + 1 }))}
      >
        add +1 to store
      </button>
    </div>
  );
};

export default ComponentA;
```
The above component simply imports the setter and getter functions of the store in order to set and get the current state of the store.

```jsx
// Component B.jsx
import { store } from "./store";

const ComponentB = () => {
  const unreactiveLocalValue = store.count;
  //Note: this will not behave reactively

  return (
    <div>
      <h2>From B: {store.count}</h2>
    </div>
  );
};

export default ComponentB;
```
This is a seperate component which serves the purpose of displaying the current state of the store and the values within.

You can also make use of the `createSignal()` primitive, like so:

```js
//store.js
import { createSignal } from "solid-js";

export const [storeUsingSignal, setStoreUsingSignal] = createSignal(0);
```

```jsx
// Component A.jsx
import { setStoreUsingSignal, storeUsingSignal } from "./store";

const ComponentA = () => {
  const reactiveLocalValue = storeUsingSignal;
  // This ðŸ‘† will behave reactively

  const unreactiveLocalValue = storeUsingSignal();
  // This ðŸ‘† will not behave reactively

  return (
    <div>
      <button onclick={() => setStoreUsingSignal((prev) => prev + 1)}>
        add +1 to store
      </button>
    </div>
  );
};

export default ComponentA;
```

```jsx
// Component B.jsx
import { storeUsingSignal } from "./store";

const ComponentB = () => {
  const reactiveLocalValue = storeUsingSignal;
  // This ðŸ‘† will behave reactively

  const unreactiveLocalValue = storeUsingSignal();
  // This ðŸ‘† will not behave reactively

  return (
    <div>
      <h2>From B: {storeUsingSignal}</h2>
      <h2>From B: {reactiveLocalValue}</h2>
    </div>
  );
};

export default ComponentB;
```
Take note of the comments within the code and how reactivity changes when `createStore()` or `createSignal()` is used.

## Rendering Mechanisms 

