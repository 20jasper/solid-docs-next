import {Aside} from "~/components/configurable/Aside"

# Stores

Solid has a "Store" function that works as a state management primitive, similar to [signals](/essentials/signals).
While signals manage a single piece of state, stores are capable of managing multiple.
Within Solid, these stores can spawn a network of reactive signals, each corresponding to a particular property which can be useful when working with complex state.

## Creating a store

Solid's `createStore` function provides the entry point to set up a store:

```jsx
import { createStore } from "solid-js/store";
```

Stores were intentionally designed to manage data structures like objects and arrays but are capable of handling other data types, such as strings and numbers.
With including JavaScript's [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) mechanism, reactivity extends beyond just the top-level objects or arrays.
It can now also target nested properties and elements within these structures creating a dynamic tree of reactive data.

```jsx
// Initialize store
const [store, setStore] = createStore({
    userCount: 3,
    users: [
        {
            id: 0,
            username: 'felix909',
            location: 'England',
            loggedIn: false,
        },
        {
            id: 1,
            username: 'tracy634',
            location: 'Canada',
            loggedIn: true,
        },
        {
             id: 1,
            username: 'johny123',
            location: 'India',
            loggedIn: true,
        }
    ]
})
```

### Accessing values

Store properties can be accessed directly from the state proxy through directly referencing the targeted property:

```jsx
console.log(store.userCount) // Outputs: 3
```

Accessing stores within a tracking scope follows a similar pattern to signals.
While signals are created using the `createSignal` function and require calling the signal function to access their values, store values can be directly accessed without a function call.
This provides access to the store's value directly within a tracking scope:

```jsx
const App = () => {
  const [mySignal, setMySignal] = createSignal("This is a signal.")
  const [store, setStore] = createStore({
    userCount: 3,
    users: [
      {
        id: 0,
        username: 'felix909',
        location: 'England',
        loggedIn: false,
      },
      {
        id: 1,
        username: 'tracy634',
        location: 'Canada',
        loggedIn: true,
      },
      {
        id: 2,
        username: 'johny123',
        location: 'India',
        loggedIn: true,
      }
    ]
  })
  return (
    <div>
      <h1>Hello, {store.users[0].username}</h1> // Accessing a store value
      <span>{mySignal()}</span> // Accessing a signal
    </div>
  );
};
```

### Modifying store values

Updating values within a store is best accomplished using a setter provided by the `createStore` initialization.
This setter allows for the modification of a specific key and its associated value, following the format `setStore(key, newValue)`:

```jsx
setStore("users", (otherUsers) =>[ 
    ...otherUsers,
    {
    id: 3,
    username: 'michael584',
    location: 'Nigeria',
    loggedIn: false
}])
```

Modifying a store using this method is referred to as "path syntax." 
In this approach, the initial arguments are used to specify the keys that lead to the target value you want to modify, while the last argument provides the new value.

<Aside>
  Separating read and write capabilities to a store presents a valuable debugging advantage.
  It facilitates the tracking and control of which components can access or change store values.
</Aside>

### Path syntax flexibilty 

String keys are frequently used to precisely target particular values.
By specifying these exact key names, you can direclty retrieve the desired information.
However, path syntax goes beyond string keys and offers more versatility when accessing targeted values.

Instead of employing the use of just single string keys, there is the option of using an array of keys.
This method grants you the ability to select multiple properties within the store, facilitating accessed to nested structures.
Alternatively, you can use filtering functios to access keys based on dynamic conditions or specific rules.

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=aUOwffJd4QDWWDi22XI8DA&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=aUOwffJd4QDWWDi22XI8DA)

The flexibility in path syntax makes for efficient navigation, retrieval, and modification of data in your store, regardless of the store's complexity or the requirement for dynamic access scenarios within your application.

## Store utilities

### Store updates with `produce`
 
Rather than directly modifying a store with setters, Solid has the `produce` utility.
This utility provides a way to work with data as if it were a [mutable](https://developer.mozilla.org/en-US/docs/Glossary/Mutable) JavaScript object.
`produce` also provides a way to make changes to multiple properties at the same time which eliminates the need for multiple setter calls.

```jsx
import { produce } from "solid-js/store"

// without produce
setStore(0, 'username', 'newUsername')
setStore(0, 'location', 'newLocation')

// with produce
setStore(0,
produce((user) => {
  user.username = 'newUsername'
  user.location = 'newLocation'
}))
```

`produce` and `setStore` do have distinct functionalities. 
While both can be used to modify the state, the key distinction lies in how they handle data.
`produce` allows you to work with a temporary draft of the state, apply the changes, then produce a new [immutable](https://developer.mozilla.org/en-US/docs/Glossary/Immutable) version of it.
Comparatively, `setStore` provides a more straightforward way to update the store directly, without creating a new version.

It's important to note, however, `produce` is specifically designed to work with arrays and objects. 
Other collection types, such as JavaScript Sets and Maps, are not compatible with this utility.

### Data integration with `reconcile`

When new information needs to be merged into an existing store `reconcile`, a utlity for Solid's stores, can help.
`reconcile` determines the differences between new and existing data, initiating updates only when there are *changed* values which avoids unneccessary updates.

```jsx
const { createStore, reconcile } from "solid-js/stores"

  const [data, setData] = createStore({
    animals: ['cat', 'dog', 'bird', 'gorilla']
    })

  const newData = getNewData() // eg. contains ['cat', 'dog', 'bird', 'gorilla', 'koala']
  setData('animals', reconcile(newData))

```

In this example, the store will look for the differences between the existing and incoming data sets.
Consequently, only `'koala'` - the new edition - will cause an update.

## Extracting raw data with `unwrap`

When there is a need for dealing with data outside of a reactive context, the `unwrap` utlity offers a way to transform a store to a standard [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

This conversion serves several important purposes. 
Firstly, it provides a a snapshot of the current state without the processing overhead associated with reactivity. 
This can be useful in situations where an unaltered, non-reactive view of the data is needed.

Additionally, `unwrap` provides a means to interface with third-party libraries or tools that anticipate regular JavaScript objects. 
This utility acts as a bridge, facilitating smooth integration with external components and simplifying the incorporation of stores into various applications and workflows.

```jsx
import { createStore, unwrap } from 'solid-js/store'

const [data, setData] = createStore({
    animals: ['cat', 'dog', 'bird', 'gorilla']
  })

const rawData = unwrap(data)
```