import {Aside} from "~/components/configurable/Aside"

# Stores

Solid's stores function as a state management primitive, similar to [signals](/essentials/signals).
While signals manage a single piece of state, however, stores can manage multiple pieces.
Within Solid, these stores can spawn a network of reactive signals, each corresponding to a particular property making them important when managing more complex state.

## Creating a store

Solid's `createStore` function provides the entry point to set up a store:

```jsx
import { createStore } from "solid-js/store";
```

Stores were created to handle complex data structures like objects and arrays, but accept other data types like strings and numbers.
With having JavaScript's [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) mechanism built in, reactivity will target not just the top-level objects or arrays, but their nested properties and elements as well.
This allows stores to wrap their properties to create a dynamic tree of reactive data.

```jsx
// Initialize store
const [store, setStore] = createStore({
    userCount: 3,
    users: [
        {
            id: 0,
            username: 'felix909',
            location: 'England',
            loggedIn: false,
        },
        {
            id: 1,
            username: 'tracy634',
            location: 'Canada',
            loggedIn: true,
        },
        {
             id: 1,
            username: 'johny123',
            location: 'India',
            loggedIn: true,
        }
    ]
})
```

### Accessing values

Store properties can be accessed directly from the state proxy by directly reference your targeted property:

```jsx
console.log(store.userCount) // Outputs: 3
```

Accessing stores within a tracking scope works the same way.
Where signals make use of the `createSignal` function, however, store values do not need to be called when accesed:

```jsx
const App = () => {
  const [mySignal, setMySignal] = createSignal("This is a signal.")
  const [store, setStore] = createStore({
    userCount: 3,
    users: [
      {
        id: 0,
        username: 'felix909',
        location: 'England',
        loggedIn: false,
      },
      {
        id: 1,
        username: 'tracy634',
        location: 'Canada',
        loggedIn: true,
      },
      {
        id: 2,
        username: 'johny123',
        location: 'India',
        loggedIn: true,
      }
    ]
  })
  return (
    <div>
      <h1>Hello, {store.users[0].username}</h1> // Accessing a store value
      <span>{mySignal()}</span> // Accessing a signal
    </div>
  );
};
```

**Note:** While store values can be accessed directly, `mySignal` requires a function call.
In using the reactive references, the UI will maintain its reactivity as values change.

### Modifying store values

In Solid, updating values within a store is best accomplished using a setter provided by the `createStore` initialization.
This setter allows for the modification of a specific key and its associated value, following the format `setStore(key, newValue)`:

```jsx
setStore("users", (otherUsers) =>[ 
    ...otherUsers,
    {
    id: 3,
    username: 'michael584',
    location: 'Nigeria',
    loggedIn: false
}])
```

Modifying a store using this method is referred to as "path syntax." 
Initial arguments specify the targeted keys, while the last argument provides the new value.
String keys are commonly used in path syntax to access specific values, however, keys can also be accessed via an array or through filtering functions.

<a href="https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=oSTsswqcmp8vcqVKP6htbg">View on Eraser<br /><img src="https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=oSTsswqcmp8vcqVKP6htbg&type=embed" /></a>

<Aside>
  Separating read and write capabilities to a store presents a valuable debugging advantage.
  It facilitates the tracking and control of which components can access or change store values.
</Aside>

## Working with Sets and Maps

When using JavaScript's [sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) and [maps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) inside a store, mutating them directly does not trigger changes.
Instead, to update they require a new reference each time they are updated:

```jsx

```

## Store utilities

### Store updates with `produce`
 
Rather than directly modifying the store with setters, Solid has the `produce` utility that provides a way to work with data as if it were a [mutable](https://developer.mozilla.org/en-US/docs/Glossary/Mutable) JavaScript object. 
This provides a way to make changes to multiple properties simultaneously, eliminating the need for multiple setter calls.

```jsx
import { produce } from "solid-js/store"

// without produce
setStore(0, 'username', 'newUsername')
setStore(0, 'location', 'newLocation')

// with produce
setStore(0,
produce((user) => {
  user.username = 'newUsername'
  user.location = 'newLocation'
}))
```

`produce` and `setState` have distinct functionalities. 
While both can be used to modify the state, the key distinction lies in how they handle data.
`produce` allows you to work with a temporary draft of the state, apply the changes, then produce a new [immutable](https://developer.mozilla.org/en-US/docs/Glossary/Immutable) version it.
Comparatively, `setState` provides a more straightforward way of updating the state directly, without creating a new version.

It's important to note, however, that `produce` is specifically designed to work with arrays and objects. 
Other collection types, such as JavaScript Sets and Maps, are not compatible with this utility.

### Data integration with `reconcile`

In applications, there may be instances where new information needs to be merged into an existing store.
`reconcile`, a utlity for Solid's stores, was designed to help with this.
It determines the differences between the new and existing data, initiating updates only when there are changed values. 
This avoids any unneccessary updates for changed elements.

```jsx
const { createStore, reconcile } from "solid-js/stores"

  const [data, setData] = createStore({
    animals: ['cat', 'dog', 'bird', 'gorilla']
    })

  const newData = getNewData() // eg. contains ['cat', 'dog', 'bird', 'gorilla', 'koala']
  setData('animals', reconcile(newData))

```

In this example, the store will looks for the differences between the existing and incoming data sets.
Consequently, only the `'koala'` - the new edition - causes an update.

## Extracting raw data with `unrap`

In situations where you may need to interact with data outside of a reactive context, the `unwrap` utlity offers a way to convert a store to a standard [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

If there is a need for a snapshot of the current state, without the reactive overhead, `unwrap` provides thisn immediate representation of the store's data.
Additionally, it also offers a way to interact with third-party libraries or tools that expect regular JavaScript objects. 

```jsx
import { createStore, unwrap } from 'solid-js/store'

const [data, setData] = createStore({
    animals: ['cat', 'dog', 'bird', 'gorilla']
  })

const rawData = unwrap(data)
```