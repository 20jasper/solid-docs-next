import { Aside } from "~/components/configurable/Aside";

# Effects

In Solid, effects are functions that are triggered when the signals they depend on change. 
They play a crucial role in managing side effects in applications, such as DOM manipulations, data fetching, and subscriptions.

## Using an effect

`createEffect`  is called as a function that contains the side effect you want to perform:

```jsx
import { createEffect } from "solid-js"

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});
```

<Aside>
  `createEffect` runs whenever any of the signals it relies on changes. 
  This ensures that your side effects always respond to the latest state, even if the values have not changed.
</Aside>

## Initiating and observing dependencies

Upon initial load, `createEffect`  is executed immediately. 
As a result, it will then be subscribed to any dependencies within it, where it tracks any changes in its dependency values. 
If any of the dependencies change, the effect will be re-run. 
It's important to note that if an effect does not have any dependencies, it will only execute once - during the initial load.

```jsx
createEffect(() => {
  console.log("hello") // will run only once
});

createEffect(() => {
  console.log(count()) // will run every time count changes
})
```

`createEffect` dependencies can be a variety of elements. 
These include variables, signals, props, context, or any other reactive values that the effect can rely on.
Solid automatically manages the subscription and reactivity to these elements which improves the tracking and minimizes the chance of overlooking or incorrectly identifying dependencies.

### Tracking signals

Using `createEffect` to wrap a signal establishes a subscription to it. 
This immediate subscription is important since it allows the effect to track the changes in the signal's value, which causes it to observe any changes that may happen and react accordingly.

```jsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count()); // Logs the current value of count whenever it changes
});
```

In this example, `createEffect` subscribes to the `count` signal. 
This means that any change in `count` notifies the effect, which then responds by logging the updated value. 

#### Managing multiple signals

Effects can monitor several signals simultaneously. 
This means that a single effect can subscribe to multiple signals, and similarly, multiple effects can keep track of a single signal. 

When an effect is set to observe multiple signals, it creates a **separate** subscription for each one. 
These individual subscriptions allow the effect to track each signal and detect any changes. 
If any of the observed signals change, the *whole* effect will run again to update and match the current state.

```jsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);
const [message, setMessage] = createSignal("Hello");

createEffect(() => {
  console.log(count(), message()); // Logs the current values of count and message whenever either changes
});
```

For this example, the `createEffect` is tracking the changes in both `count` and `message`.
When *either* signal changes, the effect is triggered, logging the values of both signals to the console. 

<Aside>
  When a signal updates, only the computations that depend on it are executed. 
  These occur sequentially, but the order can vary, so relying on a specific order is not recommended. 
  Additionally, while an effect is always guaranteed to run when a signal updates, the execution might not be instantaneous. 
</Aside>

## Nested effects

Nesting effects allow each effect to independently track its own changes, ensuring that the inner effect does not interfere with the outer one.

```jsx
createEffect(() => {
  console.log("Outer effect starts");
  createEffect(() => console.log("Inner effect"));
  console.log("Outer effect ends");
});
```

This structure helps organize code and manage dependencies. 
When an inner effect is triggered, it does **not** affect the outer effect. 
Any signals that are accessed within the inner effect is registered as a dependency *only for the inner effect*. 
When the signal that is a dependency of the inner effect changes, it will trigger only the inner effect to re-run, not the outer one. 
This stack-like behaviour keeps each effect tracking its own dependencies independently.

## Manual disposal

Effects in Solid continue running *unless* they are nested within another effect or a function called [`createRoot`](/reference/createRoot). 
Using `createRoot` provides a way to *manually* stop an effect, preventing it from unnecessarily running:

```jsx
const [count, setCount] = createSignal(1);
let stopEffect;

createRoot(stop => {
  stopEffect = stop;
  createEffect(() => console.log(count()));
});

stopEffect(); // Stopping the effect when we want
```

This manual control over the lifecycle of effects is particularly useful in scenarios where an effect is no longer needed, which improves resource management.

## Derived state

Derived state is when new state values are created based on the original ones. 
By establishing a derived state, you ensure automatic updates and responses to changes in the primary state without the hassle of juggling multiple signals.

```jsx
const [count, setCount] = createSignal(1);
const doubleCount = () => count() * 2;

createEffect(() => console.log(count()));
createEffect(() => console.log(doubleCount()));
```

In this example, the system remains responsive to any changes in the `count` signal. 
Because `doubleCount` is dependent on `count`, whenever there's a change in `count`, the effect tied to `doubleCount` is activated, ensuring that the derived state is up-to-date.

Opting for a function, like `doubleCount`, to shape derived state from a main signal is an alternative to overseeing multiple distinct states. 
The presence of many signals, especially when they're interrelated, can become difficult to keep track of and introduce errors due to frequent update requirements. 
Furthermore, this approach doesn not create new computations but uses the current effect as a listener.