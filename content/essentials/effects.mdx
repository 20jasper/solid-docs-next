import { Aside } from "~/components/configurable/Aside";

# Effects

In Solid, effects are functions that are triggered when the signals they depend on change. 
They play a crucial role in managing side effectives reactively in applications, such as DOM manipulations, data fetching, and subscriptions.

## Using an effect

To create an effect, import`createEffect` from Solid:

```jsx
import { createEffect } from "solid-js";
```

Once called, call `createEffect`  with a function that contains the side effect you want to perform:

```jsx
const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});
```

<Aside>
The function you pass to `createEffect`  is re-invoked whenever any of the signals it relies on changes. 
This ensures that your side effects always respond to the latest state.
</Aside>

## Initiating and observing dependencies

Upon initial load, `createEffect`  is executed immediately. 
As a result, it will then be subscribed to any dependencies within it, allowing the effect to monitor any changes in the dependency values. 
If any of the dependencies change, the effect will be re-run. 
It's important to note that if an effect does not have any dependencies, it will only execute a single time during the initial load.

```jsx
createEffect(() => {
  console.log("hello") // will run only once
});

createEffect(() => {
  console.log(count()) // will run every time count changes
})
```

In the context of `createEffect`, dependencies can be a variety of elements. 
These include variables, signals, props, context, or any other reactive values that the effect can rely on.
Solid automatically manages the subscription and reactivity to these elements which improves the tracking and minimizes the chance of overlooking or incorrectly identifying dependencies.

### Tracking signals

In Solid, using `createEffect` to wrap a signal establishes a subscription to it. 
This immediate subscription is important because it allows the effect to track the changes in the signal's value, allowing observe any changes that may happen.

```jsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count()); // Logs the current value of count whenever it changes
});
```

In this example, `createEffect` subscribes to the `count` signal. 
This means that any change in `count` notifies the effect, which then responds by logging the updated value. 

#### Managing multiple signals

Effects can monitor several signals simultaneously. 
This means that a single effect can subscribe to multiple signals, and similarly, multiple effects can keep track of a single signal. 

When an effect is set to observe multiple signals, it creates a separate subscription for each one. 
These individual subscriptions allow the effect to track each signal and detect any changes. 
If any of the observed signals change, the whole effect will run again to update and match the current state.

```jsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);
const [message, setMessage] = createSignal("Hello");

createEffect(() => {
  console.log(count(), message()); // Logs the current values of count and message whenever either changes
});
```

For this example, the `createEffect` is tracking the changes in both `count` and `message`.
When either signal changes, the effect is triggered, logging the updated values to the console. 

<Aside>
When a signal updates, only the computations that depend on it are executed. 
These occur sequentially, but the order can vary, so relying on a specific order is not recommended. 
Additionally, while an effect is always guaranteed to run when a signal updates, the execution might not be instantaneous. 
</Aside>

## Nested effects

Nesting effects allows each effect to independently track its own changes, ensuring that the inner effect does not interfere with the outer one.

```jsx
createEffect(() => {
  console.log("Outer effect starts");
  createEffect(() => console.log("Inner effect"));
  console.log("Outer effect ends");
});
```

This structure helps organize code and manage dependencies. 
When an inner effect is triggered, it does not affect the outer effect. 
Any signals that are accessed within the inner effect is registered as a dependency only for the inner effect. 
When the signal that is a dependency of the inner effect changes, it will trigger only the inner effect to re-run, not the outer one. 
This stack-like behaviour ensures that each effect tracks its own dependencies independently.

## Manual disposal

Effects in Solid continue running unless they are nested within another effect or a function called `createRoot`
.Using `createRoot` is important since it provides a way to manually stop an effect, preventing it from unnecessarily running:

```jsx
const [count, setCount] = createSignal(1);
let stopEffect;

createRoot(stop => {
  stopEffect = stop;
  createEffect(() => console.log(count()));
});

stopEffect(); // Stopping the effect when we want
```

This manual control over the lifecycle of effects is particularly useful in scenarios where an effect is no longer needed, improving resource management.

## Derived state

Derived state allows you to create new values of state based on the original ones. 
This provides you with the ability to automatically update and react to changes in the original state, removing the need to manage multiple signals.

```jsx
const [count, setCount] = createSignal(1);
const doubleCount = () => count() * 2;

createEffect(() => console.log(count()));
createEffect(() => console.log(doubleCount()));
```

In this example, the effect remains reactive to changes in the original signal, `count` . With `doubleCount`  being based on `count` , it will also be updated trigger the effect to re-run. 
This maintains reactivity since the effect will re-run when the original signal updates, which automatically updates the derived state. 
While not technically a getter function, functions like `doubleCount`  might be referred to as signals within the Solid community since they often act similar. 

You can use a function to create derived state from an original signal instead of maintaining separate ones. 
Using multiple signals for dependent states can be difficult and introduce errors because of the need to update. 
Where these signals are called do not matter and doing this does not create a new computation, but it uses the existing effect as a global listener.