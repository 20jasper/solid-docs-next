import { Aside } from "~/components/configurable/Aside";

# Class & Style Bindings

Similar to HTML, Solid uses `class` and `style` attributes to style elements via [CSS (Cascading Style Sheets)](https://developer.mozilla.org/en-US/docs/Glossary/CSS).

* **Class Attribute**: Enables styling one or more elements through CSS rules.
* **Style Attribute**: Inline styles that style single elements.

## Inline styling

The `style` attribute lets you style a single element and define CSS variables dynamically during runtime. 
Solid allows `style` in both string (e.g. `<div style="color: red;"` /> and object forms  (e.g. `<div style={{ "color": "red" }}>` ).

If you are styling using the object form, the keys will require dash-case form and any units must be explicitly provided:

```jsx
<div style={{
  color: `red`,
 "font-weight": 800,
 "font-size": '2rem'
}}
>
  Some Text
</div>
```

Inline styles come in handy for rapid prototyping, setting dynamic CSS variables, and overriding classes. 
However, because Solid uses JSX, it is not recommended to use the `style` tag within the JSX code directly. 
Doing this clutters the component logic, making the code less readable and harder to maintain over time.

## Classes

Through the `class` attribute, you can style elements using CSS. The `class` attribute offers self-documentation and performance advantages over `style`.

For a structured approach, pair CSS files with their respective component files. 
Importing these files will globally scope them, meaning elements using those classes will inherit those styles automatically. 

```jsx
import "./Card.css";
function Card() {
  // ...
}
```

In scenarios where you might want to conditionally set classes, Solid offers the built-in [`classList`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) JSX attribute. 
This attribute takes an object where the key represents the class name(s) and the value is a boolean expression. 
When the value is to true, the class is applied; when false, it is removed.

```tsx
  const [current, setCurrent] = createSignal("foo");

    <button
     class={current() === 'foo' ? 'selected' : ''}
     onClick={() => setCurrent('foo')}
    >foo</button>
```

## Dynamic styling

Dynamic styling allows interfaces to adapt and respond to various factors, such as user interaction or device preferences. 

Component states serve as a primary mechanism for managing dynamic data within a component.
This state can directly influence styles or, more flexibly, CSS variables.

Rather than changing a style directly, these variables can be changed based on a single state:

```tsx
const [theme, setTheme] = createSignal("light");

<div class={theme() === 'light' ? 'light-theme' : 'dark-theme'}>
  This div's theme is determined dynamically!
</div>
```

Props are another way to change styles. 
By passing props to components, you can adapt styles based on the component's usage or the data it receives:

```tsx
function ThemedButton({ theme }) {
  return (
    <button class={theme}>
      {theme === 'light' ? 'Light Button' : 'Dark Button'}
    </button>
  );
}
```

To dive deeper into how to style your Solid components in our [detailed guide](guides/styling-your-components).