# Conditional Rendering

Conditional rendering in Solid introduces dedicated components that simplify and enhance the way UI is handled based on the presented conditions. 
These components offer a more straightforward and readable way to manage these UI elements to make code more organized and maintainable.

## `<Show>`

The `<Show>` component integrates JavaScript control logic flow within templates, creating a more readable way to handle conditionals.
It can be directly imported from Solid:

```JSX
import { Show } from "solid-js"
```

`<Show>` uses the `when` property is where the condition for rendering is specified. 
It accepts a boolean expression, which could be as simple as a boolean variable or more complex expressions that evaluate to a boolean value.
The expression in the `when` property is re-evaluated whenever there's a change in the state or props that it depends on.

The `fallback` property is optional, however. 
Any valid JSX content or components can act as a fallback, ranging from simple text or HTML elements, to more complex components.

```jsx
<Show when={!data.loading()} fallback={<div>Loading...</div>}>
  <h1>
    Hi, I am {data.name}.
  </h1>
</Show>
```

With this example, when the `!data.loading()` condition holds `true`, the primary content between the `<Show>` tags is rendered. 
If it evaluates to `false`, the fallback content is rendered, if provided.

When certain conditions are not met, `<Show>` can be used to show alternative content, loaders, error messages, or anything else that makes sense in the context of your application.

## `<Switch>` and `<Match>`

Handling multiple conditions in Solid can be managed through the `<Switch>` and `<Match>` components, which are similar to JavaScript's [switch/case](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch) structure. 
To use these components, import them from Solid:

```jsx
import { Switch, Match } from "solid-js";
```

Simlar to show, `<Switch>` has the optional `fallback` prop available, which will specify the content that will be rendered if none of the `<Match>` components evaluate to true.

`<Match>`, however, is nested within `<Switch>` to represent individual conditions.
These components will show based on when the `when` prop is evaluated to be true.

These components will evaluate each condition *in sequence* and render the corresponding outcome of the **first** true condition encountered:

```jsx
<Switch fallback={<p>Fallback content</p>}>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
</Switch>
```

Opting for this approach can create more readable and organized code. A nested `<Show>` component can be replaced with `<Switch>` and `<Match>` for the same results:

```jsx
// nested show
<Show
    when={x() > 10}
      fallback={
        <Show
          when={5 > x()}
          fallback={<p>{x()} is between 5 and 10</p>}
        >
          <p>{x()} is less than 5</p>
        </Show>
      }
    >
      <p>{x()} is greater than 10</p>
    </Show>

// switch/match alternative:

<Switch fallback={<p>{x()} is between 5 and 10</p>}>
  <Match when={x() > 10}>
    <p>{x()} is greater than 10</p>
  </Match>
  <Match when={5 > x()}>
    <p>{x()} is less than 5</p>
  </Match>
</Switch>
```

## Dynamic

`<Dynamic>` introduces a way to dynamically select and render components based on *varying* data. 
It can be imported through Solid:

```jsx
import { Dynamic } from "solid-js";
```

`<Dynamic>` can either take a string representing a native element or a component function and it will render the rest of the provided props:

```jsx
import { createSignal, Switch, Match, For } from "solid-js";

const RedDiv = () => <div style="color: red">Red</div>;
const GreenDiv = () => <div style="color: green">Green</div>;
const BlueDiv = () => <div style="color: blue">Blue</div>;

const options = {
  red: RedDiv,
  green: GreenDiv,
  blue: BlueDiv
}

function App() {
  const [selected, setSelected] = createSignal("red");

  return (
    <>
      <select value={selected()} onInput={e => setSelected(e.currentTarget.value)}>
        <For each={Object.keys(options)}>{
          color => <option value={color}>{color}</option>
        }</For>
      </select>
      <Dynamic component={options[selected()]} />
    </>
  );
}
```

In this example, the `component` prop of `<Dynamic>` is assigned a value from the `options` array, which is indexed by the result of the `selected()` function call. 
This dynamic assignment results in rendering the *chosen* component or element with the provided properties.

Using `<Dynamic>` can result in more compact and clean code other conditional rendering options, if it was replaced by a `<Switch>` statement, it would look like the following:

```jsx
<Switch fallback={<BlueDiv />}>
  <Match when={selected() === 'red'}><RedDiv /></Match>
  <Match when={selected() === 'green'}><GreenDiv /></Match>
</Switch>
```

Choosing to use `<Dynamic>` can lead to a more compact code base when comparing to the use of multiple `<Switch>` or `<Switch>/<Match>` components.

## Portal

The `<Portal>` element assists in tackling the difficulties that are typically encountered with overlay elements like modals.
When an element requires rendering outside of the usual document flow, challenges related to stackign contents and z-index can present.
`<Portal>` enables the rendering elements of these elements so they are rendered correctly and interactively.

```jsx
import { Portal } from "solid-js";

<Portal>
  <div class="popup">...</div>
</Portal>
```

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=hBlsXychIW_yV64t1x5IZA&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=hBlsXychIW_yV64t1x5IZA)

The content nested within `<Portal>` is positioned at a designated location when shown.
By default, Solid will render these elements in a `div` within `document.body` to make sure they are not bound by the styling or layout restrictions of the parent component.

Using `<Portal>` can be particularly useful in cases where elements, like information popups, might be clipped or obscured due to the overflow settings of their parent elements.
By encapsulating the element within `<Portal>`, it is effectively lifted from the standard flow and positioned in a manner that is both visually accessible and no longer effected by the layout constraints of its surrounding environment.

## Error Boundary

The `<ErrorBoundary>` component in Solid serves as a protective layer around child components that are susceptible to throwing errors. 
By catching these errors, it prevents them from propagating and causing the entire application to crash:

```jsx
import { ErrorBoundary } from "solid-js";

<ErrorBoundary fallback={err => <div>Error: {err.message}</div>}>
  <PotentiallyErroneousComponent />
</ErrorBoundary>
```

[View on Eraser![](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=uawsugh__apVsVq2YQmo_Q&type=embed)](https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=uawsugh__apVsVq2YQmo_Q)

In this setup, the `fallback` prop is important. 
It determines what will be rendered in place of the child component(s) if an error is thrown.
The `fallback` prop can take a function that receives the caught error as an argument, providing a flexible way to handle different error scenarios.

If a component within `<ErrorBoundary>` throws an error, instead of causing a crash, `<ErrorBoundary>` will catch the error and render the fallback UI. 
This way, even when a component fails, the user has a controlled UI response instead of a broken interface. 
The fallback UI can be used to display the error message, or provide a friendly notification to the user.
This mechanism aids in error containment and provides a better user experience even when unexpected issues arise in the UI.