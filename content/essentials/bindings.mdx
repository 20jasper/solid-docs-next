import { Aside } from "~/components/configurable/Aside";

# Bindings

## Class & style

Similar to HTML, Solid uses class  and style attributes to style elements via [CSS (Cascading Stylesheets)](https://developer.mozilla.org/en-US/docs/Glossary/CSS).

* **Class Attribute**: Important when styling one or more elements.
* **Style Attribute**: Inline styles that serve the purpose of styling a single element.

### Inline styling

The `style` attribute lets you style a single element and define CSS variables dynamically during runtime. 
Solid acknowledges `style` in both string (e.g. `<div style="color: red;"` /> and object forms  (e.g. `<div style={{ "color": "red" }}>` ).

If you are styling using the object form, the keys will require dash-case form and any units must be explicitly provided:

```html
<div style={{
  color: `red`,
* font-weight": 800,
* font-size": '2rem'
}}
>
  Some Text
</div>
```

Inline styles come in handy for rapid prototyping, setting dynamic CSS variables, and overriding classes. 
However, because Solid uses JSX, it is not recommended to use the `style` tag within the JSX code directly. 
Doing this clutters the component logic, making the code less readable and harder to maintain over time.

### Classes

Through the `class` attribute, you can style elements using CSS. 
Solid's support for `classList` lets you switch classes based on dynamic values. 
The `class` attribute recommended for its self-documentation and it also offers performance advantages. 

For a structured approach, pair CSS files with their respective component files. 
Importing these files will globally scope them, meaning elements using those classes will inherit those styles automatically. 

```jsx
import "./Card.css";
function Card() {
  // ...
}
```

Dive deeper into how to style your solid components in our [detailed guide](guides/styling-your-components).

## Event handlers

Events handlers play an important role in capturing user interactions and executing the relevant logic based on those interactions.

In Solid, event handlers are prefixed with `on`, to help distinguish them from other properties and attributes in your components.
They can be written as either `onClick` and `onclick`, catering to different coding styles or project conventions.

```tsx
<button onClick={handleClick}>Click me</button>
```

<Aside>
  **Note**: 
  Events remain static and are _not_ reactive.
  This is to avoid the costly process of continuously attaching and detaching listeners.
  Given that event handlers are invoked like regular functions upon each event trigger, there's no inherent need for them to be reactive.
  <br />
  If necessary, you can streamline your handlers accordingly:

    ```tsx
    <div onClick={() => props.handleClick?.()} />
    ```

</Aside>

### Event delegation

Rather than attaching event listeners to every individual element, Solid uses event delegation. 
This technique consolidaates event listening at a higher level, allowing events to be captured effectively. 
Supported events such as `click`, `mouseover`, and `keydown` are just a few examples that follow this, to view the full list see the [reference section](#delegated-events).

**Note**: If you need to support other casings or want to avoid the event delegation, you can use [on:](/reference/on-and-oncapture) to match event handlers that follows the colon.

### Binding events

Solid binds data to event handlers without incurring the usual overhead of JavaScript's [`bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind) method or additional closures. 
To achieve this you will have to pass an array to the event handler. Notably, the **second item** of the array will be supplied as the handler's **first argument**.

```jsx
const handler = (data, event) => {
   console.log('Data:', data, 'Event:', event);
}

<button onClick={[handler, 'Hello!']}>Click Me</button>
```

In this example, the string `'Hello!'` (the second item in the array) is passed as the data parameter (the first argument of the handler function) when the button is clicked.

## Refs

Refs, or references, allow you to have direct access to DOM element. 

To create a `ref` in Solid, you can get a reference to an element through assigning it to avariable: 

```jsx
const myDiv = <div>My Element</div>;
```

For a more idiomatic way, Solid provides the `ref` attribute. Refs in Solid are assignments, like above, that occur at creation time before elements are attached to the document DOM.
To use this, you simply need to declare a variable and use it as a ref attribute:

```tsx
let myDiv;

<div ref={myDiv}>My Element</div>

```

This lets you access its properties and methods directly, allowing for manipulatinos such as animations and event handling.

### Callbacks

Refs can also take the form of a callback function.
This method can be convenient for encapsulating logic, especially when there is no need to wait until the elements are attached:

```tsx
let myDiv;

<div ref={(el) => myDiv = el}>My Element</div>
```

Callback refs provide a more flexible way to set refs and can be beneficial in various scenarious, such as when you need to attach event listeners to the DOM elements immediately after creation.

### Forwarding refs

Forwarding refs provide a way to expose one of the inner elements' references to a parent component.
By doing this, the parent component can directly access and interact the inner elements.

When a component receives a `ref` attribute from its parent, it will come as `props.ref` in a callback form, regardless of whether the parent passed it as a simple assignment or a callback.

The component can then "forward" this ref to a desired internal element by assigning the `props.ref` directly to the `ref` attribute of that element.

Imagine there is a `Canvas` component, and from its parent, you want to directly manipulate the `canvas` element inside this Canvas component.

1. Canvas component

```tsx
function Canvas(props) {
  return (
    <div className="canvas-container">
      <canvas ref={props.ref} />
    </div>
  );
}
```

2. Parent component
```tsx
import { Canvas } from './Canvas.jsx';

function ParentComponent() {
  let canvasRef;

  const animateCanvas = () => {
    // Manipulate the canvas using canvasRef...
  };

  return (
    <div>
      <Canvas ref={canvasRef} />
      <button onClick={animateCanvas}>Animate Canvas</button>
    </div>
  );
}
```

In the `Canvas` component, we're directly assigning the incoming `props.ref` to the `ref` attribute of the internal canvas element. 
This forwards the reference to the parent component (`ParentComponent`), allowing it to have direct access to the `canvas` element.

## Directives

Directives allow the attachment of reusable behaviours to DOM elements.
The [`use:`](/reference/use) prefix is used to denote these custom directives.
Unlike props or attributes, directives operate at a lower level through providing fine-grained control over the elements they are attached to.

A directive is essential a function with a specific signature:

```typescript
function directive(element: Element, accessor: () => any): void;
```

* `element`: This is the DOM element that the directive is being applied to.
* `accessor`: A function that gives access to the value(s) passed to the directive.

The directive functions are invoked at render time but are called before the element is added to the DOM.
Due to this order, elements are fully primed with their attributes, properties, or event listeners therefore minimizing unexpected behaviours or premature interactions.

Within directives, you're able to perform a variety of tasks, including:
* creating [signals](/essentials/signals)
* initiating [effects](/essentials/managing-side-effects)
* registering [cleanup tasks](/essentials/managing-side-effects#clean-up)
* adding [event listeners](#event-listeners)
* and more.

## Reference

### Delegated Events

* [`beforeinput`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/beforeinput_event)
* [`click`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click)
* [`dblclick`](https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event)
* [`contextmenu`](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event)
* [`focusin`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focusin_event)
* [`focusout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event)
* [`input`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
* [`keydown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event)
* [`keyup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event)
* [`mousedown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event)
* [`mousemove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event)
* [`mouseout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event)
* [`mouseover`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseover_event)
* [`mouseup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event)
* [`pointerdown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerdown_event)
* [`pointermove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event)
* [`pointerout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerout_event)
* [`pointerover`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerover_event)
* [`pointerup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerup_event)
* [`touchend`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchend_event)
* [`touchmove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchmove_event)
* [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event)