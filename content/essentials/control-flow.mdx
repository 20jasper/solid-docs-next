# Control Flow

Control flow is important with managing both conditional rendering and loops. Through leveraging control flow, you can efficiently handle variations in UI elements and respond to changes in state and user interaction to create a more intuitive application.

## For
The `<For>` component is the optimal way to loop over arrays or objects. This component updates or moves DOM items as the arrays or objects evolve, preventing the complete recreation of an element. If an element changes placement, its corresponding node moves and the index will change.

To access `<For>` , you can import it directly from Solid:

```
import { For } from "solid-js";
```
The only property that `<For>` has is `each` , where you pass the array or object you want to loop over through this prop.  `<For>` requires passing the passing of a callback function, where the element is the first argument and its index is the second, similar to JavaScript's `[﻿.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)` callback:

```
<For each={cats()}>
  {(cat, index) => 
    <li>{cat.name}</li>
  }
</For>
```
<Aside>

Notably, each index acts as a signal _not_ a number. This allows for dynamic updates as the array is changed.

</Aside>

## Index
For Solid, `<Index>` is beneficial when you need to optimize the rendering of lists, especially those that include primitives. It can be imported directly from Solid:

```
import { Index } from "solid-js";
```
Similar to the `<For>`  component, the only property that `<Index>`  has is `each` , where you would pass the array or object that you wish to loop over. Additionally, it requires the passing of a callback function, with the first argument being the element and the second being the index:

```
<Index each={cats()}>{(cat, index) => <li>{cat().name}</li>}</Index>
```
### `<For>`  vs `<Index>` 
`<Index>` distinguishes itself from the `<For>` component, in that causes _fewer_ re-renders. It does this through allowing the content at each index to change without causing a re-render, whereas the `<For>` component is sensitive to changes in each piece of data it iterates over.

In `<For>` , when an array undergoes a change, such as an element shifting position within an array, the `<For>` component will manage this by simply moving the corresponding DOM node and updating the index.

In contrast, `<Index>` is concerned primarily with the index of the elements in the array. This will result in fewer re-renders because it allows the content at each index to change without triggering a re-render of the entire component.

In cases where **primitives **or **nested arrays** are used, it's recommended to use `<Index>` to mitigate any unnecessary renders. Using `<Index>` will ensure that only the _content_ at the altered index is updated, providing a more efficient approach to managing dynamic lists.

An example of when _not_ to use `<For>` is when you are working with a list of input elements, or with the contents of a list that will change frequently, but the order and length of the list remain stable.

```
import { createSignal, Index } from "solid-js";

function InputForm() {
  const [inputs, setInputs] = createSignal(["", "", ""]); // Array of strings representing input values

  return (
    <form>
      <Index each={inputs()} fallback={<p>Loading...</p>}>
        {(input, index) => (
          <input 
            type="text" 
            value={input()} 
            onInput={(e) => setInputs([...inputs().slice(0, index), e.target.value, ...inputs().slice(index + 1)])}
          />
        )}
      </Index>
    </form>
  );
}
```
In this case, despite the frequent changes to the input values, using `<Index>` would prevent unnecessary re-renders of the entire list of inputs, therefore improving performance. In contrast, with the `<For>` component, which would potentially result in the recreation of the input elements when they change.

## Show
The `<Show>` component integrates JavaScript control logic flow within templates, creating a more readable way to handle conditionals. It can be directly imported from Solid:

```
import { Show } from "solid-js"
```
`<Show>` uses the `when` property to evaluate when to render the content inside the `<Show>`. This property accepts a boolean expression or condition. The `fallback` serves as the alternative, rendering specified content or components in JSX when the condition in `when`  is not truthy:

```
<Show when={!data.loading()} fallback={<div>Loading...</div>}>
  <h1>
    Hi, I am {data.name}.
  </h1>
</Show>
```
## Switch and Match 
Handling multiple conditions can be streamlined through the use of `<Switch>`  and `<Match>` , which are similar to JavaScript's [﻿switch/case](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)﻿ structure. To use, import it from Solid:

```
import { Switch, Match } from "solid-js";
```
`<Switch>` and `<Match>`  collaboratively evaluate each condition in sequence and render the corresponding outcome of the first true condition encountered:

```
<Switch fallback={<p>Fallback content</p>}>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
</Switch>
```
The `fallback`  attribute of the `<Switch>` components defines what content will be rendered if none of the specified conditions in the `<Match>` components prove to be true. Each`<Match>` component nests within `<Switch>` , representing individual conditions. These components take a `when` prop that will contain the specific condition to be evaluated.

<Aside>

Using this approach can create more readable and organized code structure, especially when compared to the complexity that can arise from using nested `<Show>` components.

```
// nested show
<Show when={condition1}>
  <p>Outcome 1</p>
  <Show when={condition2}>
    <p>Outcome 2</p>
    <Show when={condition3}>
      <p>Outcome 3</p>
    </Show>
  </Show>
</Show>

// switch match alternative
<Switch fallback={<p>Fallback content</p>}>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
  <Match when={condition3}>
    <p>Outcome 3</p>
  </Match>
</Switch>
```
</Aside>

## Dynamic
`<Dynamic>` is component that enables the dynamic selection of components or elements based on varying data. It can be imported through Solid:

```
import { Dynamic } from "solid-js";
```
This component can take a string for a native element or a component function to render the chosen element or component with the provided props.

```
<Dynamic component={options[selected()]} />
```
In this example, the `component` prop of `<Dynamic>` is assigned a value from the `options` array, which is indexed by the result of the `selected()` function call. This dynamic assignment results in rendering the chosen component or element with the provided properties.

Opting to use `<Dynamic>` can result in more compact and clean code compared to the use of multiple `<Show>` or `<Switch>/<Match>` components for conditional rendering. It acts as an effective replacement for a `<Switch>` statement that conditional renders different components based on a selected option.

## Portal
The `<Portal>` element proves to be incredibly useful when addressing common challenges associated with floating elements such as modals. By providing a way to render elements outside the typical document flow, it helps overcome issues related to stacking contexts and z-index, ensuring that elements like modals are displayed appropriately and interactively.

```
import { Portal } from "solid-js"

<Portal>
  <div class="popup">...</div>
</Portal>
```
The child content in `<Portal>` will be inserted into a designated position. By default, Solid renders these elements in a `<div>` within `document.body` to make sure they are not confined by the parent component's styling or layout restrictions.

Using `<Portal>` is especially helpful when resolving issues where elements, such as information popups, may get clipped or cut off due to their parent's overflow settings. By wrapping the element within `<Portal>`, you essentially extract it from the normal flow. This position the element in a way that’s both visually accessible and free from the layout constraints of its surrounding environment.

## Error Boundary
Catching JavaScript errors in the user interface is important to prevent the entire application from breaking. This is where `<ErrorBoundary>` comes in. Serving as a safeguard, it wraps around child components that may throw errors:

```
import { ErrorBoundary } from "solid-js";

<ErrorBoundary fallback={err => err}>
  <Broken />
</ErrorBoundary>
```
In this scenario, the `fallback` prop is important - it specifies what should be rendered when an error is caught. This prop can be assigned a function that receives the caught error as an argument, allowing for flexibility in handling different types of errors.

When a component enclosed within `<ErrorBoundary>` crashes, it does not bring down the entire application. Instead, `<ErrorBoundary>` will catch the error in the child component tree where it will replace the crashed component with the fallback UI. This could produce the error itself or a custom message to make sure the users are not met with a broken interface.













intro

- Control flow manages conditional rendering and loops
- Offers efficient and flexible ways to handle dynamic UI
- special attributes like `if` , `else` , `each` , and `show` 
    - Used in JSX elements for conditional rendering or looping
For

- best way to loop over arrays
    - Updates or moves DOM items as array changes vs recreating
- `each`  => only prop for `<For>` 
    - Pass array you want to loop over to this prop
- Instead of writing nodes directly, pass a callback function
    - Similar to JS `map` callbaack
- Called with element as first argument and index as second
- Callback should return a node to be rendered for each element in the array
    - Each node rendered is coupled to an element in the array
    - If an element changes placement, corresponding node moves too and index changes
- Index is a signal, not a constant number
    - Allows for dynamic updates when array changes
index

- provides optimized rendering of lists, especially with primitives
- Causes fewer re-renders compared to `<For>`  in certain situations
    - `<For>`  with primitives or array of arrays can cause unnecessary re-renders
        - Mapping a list of strings to `<input>`  fields would recreate each `<input>`  on each change
- Use `<Index>`  when working with solid primitives
```
<Index each={cats()}>{(cat, i) => <li>{cat().name}</li>}</Index>
```
- Similar to `<For>` but the item is a signal and the index is fixed
- Each rendered node corresponsds to a _fixed_ spot in the array
    - When data at that spot changes, signal will update
#### `<For>` vs `<Index>` 
- For => cares about each piece of data and its _position_ can change
- Index => cares about each index and the content at each _index_ can change
show

- Allows JS control logic flow in templates
- More readable way to handle conditionals
- `when`  => condition to evaluate for showing the content
- `fallback`  => acts as the `else`  and displays when the `when`  is not truthy
switch/match

- Handle conditionals with more than two mutually exclusive options
    - Modelled after JS's `switch/case` 
- Tries to match each condition in order
- Stops and renders the first condition that evaluates to true
    - If non match, renders the fallback
```
<Switch fallback={<p>Fallback content</p>}>
  <Match when={condition1}>
    <p>Outcome 1</p>
  </Match>
  <Match when={condition2}>
    <p>Outcome 2</p>
  </Match>
</Switch>
```
- `fallback` => specifies what renders if none of the conditions in `<Match>` components evalute to be true
- `<Match>`  => used inside `<Switch>`  to specify each condition
    - Takes a `when` prop that contains the condition to evaluate
- Replacing nested `**<Show>**`  components for cleaner, more readable code.
dynamic

- Useful for rendering based on data
- Allows for dynamic component or element selection
- Takes a string for a native element or a component function
    - Renders chosen element or component with the provided props
```
<Dynamic component={options[selected()]} />
```
- More compact than using multiple `<Show>`  or `<Switch>`  components for conditional rendering.
- Replacing a `<Switch>`  statement that conditionally renders different components based on a selected option.
portal

- Useful for rendering elements outside the normal flow of the app.
- Addresses limitations with z-index and render contexts, especially for floating elements like modals.
- Child content of `<Portal>`  is inserted at a specified location.
- By default, elements are rendered in a `<div>`  in `document.body` .
```
<Portal>
  <div class="popup">...</div>
</Portal>
```
- Solving issues where an information popup gets cut off.
- Wrapping the problematic element in a `<Portal>`  pulls it out of the normal flow.
errorboundary

- To catch JavaScript errors in the UI without breaking the entire app.
- Provides a mechanism to log errors and display a fallback UI.
    - Wraps around child components that may potentially throw errors.
    - Catches errors in the child component tree and replaces it with a fallback UI.
```
<ErrorBoundary fallback={err => err}>
  <Broken />
</ErrorBoundary>
```
- `fallback`  => specifies what to render when an error is caught.
    - Can be a function that receives the error as an argument.
- Wrapping a component that has crashed to prevent it from breaking the entire app.
- Displays the error or a custom message as a fallback.