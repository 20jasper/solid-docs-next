# Understanding Fine-Grained Reactivity

Reactivity in programming establishes automatic responses to data changes, eliminating the need for manual updates to the user interface (UI). 
By connecting UI elements to the underlying data, updates become automated.

The term "fine-grained reactivity" refers to systems that allow for highly targeted behavioral changes, in contrast to approaches that only support broader, and sometimes unnecessary, updates.

**Note:** If you're new to the concept of reactivity and want to learn the basics, consider starting with our [intro to reactivity guide](/essentials/intro-to-reactivity).

## Reactive Primitives

In Solid's reactivity system, there are two key elements: signals and effects. These core elements serve as the foundation for more specialized reactive features:

* Stores are essentially clusters of signals, structured for advanced state management.
* Memos act as specialized signals that update based on the behavior of effects, ideal for computational optimization.
* Resources are a unique category of signals that automatically update when server data is fetched, enabling real-time synchronization.
* Render effects are a tailored type of effect that initiates earlier, specifically designed for managing the rendering process.

Each of these specialized features extends the basic capabilities of signals and effects to cater to various development requirements.

### Understanding signals

Signals are mutable data points, like a counter value that can be increased or decreased. 
A signal is made up of two primary functions:

* The **getter**, which allows you to read the current value of the signal.
* The *setter*, which enables you to alter or update the signal's value.

In Solid, the `createSignal` function can be used to generate a signal.
This function returns both the getter and setter as a pair in a two-element array.

```js=
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(1);

console.log(count()); // prints "1"

setCount(0); // Modifies the count value to 0

console.log(count()) // prints "0"
```

Here, `count` serves as the getter, and `setCount` functions as the setter.

### Effects

Effects are operations triggered by changes in one or more signals they depend on.
To create effects in Solid, there is the `createEffect` function.

```js=
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});
```

The effect takes a callback function that is re-invoked whenever any of the signals it relies on, such as `count`, undergoes a change.

## Building a reactive system

To grasp the concept of reactivity, it's often helpful to construct a reactive system from scratch. 
The following example will follow the observer pattern, where data entities (signals) will maintain a list of their subscribers (effects). When a signal changes, all the subscribers will be notified.

### Initial code structure

Here is a basic code outline to begin:

```jsx
function createSignal() {}

function createEffect() {}

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("The count is " + count());
});
```

### Implementing `createSignal`

The `createSignal` function performs two main tasks:
1. Initialize the value, in this case `count`, to 0.
2. Return an array with two elements: a getter and a setter function.

Implementation:

```tsx
function createSignal(initialValue) {
  let value = initialValue;
  
  function getter() {
    return value;
  }
  
  function setter(newValue) {
    value = newValue;
  }
  
  return [getter, setter];
}
```

This allows retrieval of the current value via the getter and modification through the setter. 
However, reactivity is not yet implemented.

### Implementing `createEffect`

The basic form of `createEffect` is simple:

```jsx
function createEffect(fn) {
  fn();
}
```

The core functionality emerges when linking `createSignal` and `createEffect`.

### Linking signals and effects

In order to introduce reactivity, the following steps are necessaary:
1. Maintain a reference to the current subscriber function.
2. Register this function during effect creation.
3. Add the function to a subscriber list when accessing a signal.
4. Notify all subscribers upon updating a signal.

This can be shown as:

```jsx
let currentSubscriber = null;

function createSignal(initialValue) {
  let value = initialValue;
  const subscribers = new Set();
  
  function getter() {
    if (currentSubscriber) {
      subscribers.add(currentSubscriber);
    }
    return value;
  }
  
  function setter(newValue) {
    value = newValue;
    for (const subscriber of subscribers) {
      subscriber();
    }
  }
  
  return [getter, setter];
}

function createEffect(fn) {
  currentSubscriber = fn;
  fn();
  currentSubscriber = null;
}
```

### Validating the reactive system

To validate the system, increment the `count` value at one-second intervals:

```jsxconst [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("The count is " + count());
});

setInterval(() => {
  setCount(count() + 1);
}, 1000);
```

This will display the incremented count value on the console at one-second intervals to confirm the reactive system's functionality.

## Managing lifecycles in a reactive system

In reactive systems, various elements, often referred to as "nodes", are interconnected. 
These nodes can be signals, effects, or other reactive primitives.
They serve as the individual units that collectively make up the reactive behavior of the system. 

When a node changes, the system will re-evaluate the parts connected to that node. 
This can result in updates, additions, or removals of these connections, affecting the overall behavior of the system.

Now, consider a scenario where a condition influences the data used to calculate an output:

```jsx
console.log("1. Initialize");
const [temperature, setTemperature] = createSignal(72);
const [unit, setUnit] = createSignal("Fahrenheit");
const [displayTemp, setDisplayTemp] = createSignal(true);

const displayTemperature = createMemo(() => {
  if (!displayTemp()) return "Temperature display is off";
  return `${temperature()} degrees ${unit()}`;
});

createEffect(() => console.log("Current temperature is", displayTemperature()));

console.log("2. Turn off displayTemp");
setDisplayTemp(false);

console.log("3. Change unit");
setUnit("Celsius");

console.log("4. Turn on displayTemp");
setDisplayTemp(true);
```

In this example, the `createMemo` primitive is used to cache the state of a computation. 
This means the computation doesn't have to be re-run if its dependencies remain unchanged.

The `displayTemperature` memo has an early return condition based on the value of `displayTemp`. 
When `displayTemp` is false, the memo returns a message saying "Temperature display is off," and as a result, `temperature` and `unit` are not tracked.

If the `unit` is changed while `displayTemp` is false, however, the effect won't trigger since none of the memo's current dependencies (`displayTemp` in this case) have changed.

### Synchronous nature of effect tracking

The reactivity system described above operates synchronously. 
This synchronous operation has implications for how effects and their dependencies are tracked. 
Specifically, the system registers the subscriber, runs the effect function, and then unregisters the subscriberâ€”all in a linear, synchronous sequence.

Consider the following example:

```jsx
createEffect(() => {
  setTimeout(() => {
    console.log(count());
  }, 1000);
});
```

Here, the `createEffect` function initiates a `setTimeout`, which is asynchronous. 
Because the system is synchronous, it doesn't wait for this asynchronous operation to complete. 
By the time the `count` getter is invoked within the `setTimeout`, the global scope no longer has a registered subscriber.
As a result, this `count` signal won't add the callback as a subscriber, leading to potential issues in tracking changes to count.

### Handling asynchronous effects

While the basic reactivity system is synchronous, frameworks like Solid offer more advanced features to handle asynchronous scenarios. 
For example, Solid provides the `on` function, which allows for manually specifying dependencies for an effect. 
This is particularly useful for ensuring that asynchronous operations are correctly tied into the reactive system. 