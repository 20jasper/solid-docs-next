# Understanding Fine-Grained Reactivity

Reactivity in programming establishes automatic responses to data changes, eliminating the need for manual updates to the user interface (UI). 
By connecting UI elements to the underlying data, updates become automated.

Fine-grained reactivity refers to the ability of a system to make highly targeted and specific updates.
An example of this can be seen in the contrast betwen Solid and React.
In Solid, updates are made to the targeted attribute that needs to be changed, avoiding broader, sometimes unnecessary, updates.
In contrast, React would re-execute the entire component for the singular attribute change, which can be less efficient.
Because of this, adoption of a fine-grained reactive system minimizes the unnecessary recalculations through targeting only the areas of an application that have changed, both optimizing and improving the user experieince.

**Note:** If you're new to the concept of reactivity and want to learn the basics, consider starting with our [intro to reactivity guide](/essentials/intro-to-reactivity).

## Reactive Primitives

In Solid's reactivity system, there are two key elements: signals and observers. These core elements serve as the foundation for more specialized reactive features:

* Stores are [proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) that, under the hood, create, read, and write signals.
* Memos act as specialized effects that return a signal.
update based on the behavior of effects, ideal for computational optimization.
* Resources, building on the concept of memos, convert the asynchronicity of network requests into synchronicity, where the results are embedded within a signal.
* Render effects are a tailored type of effect that initiates immediately, specifically designed for managing the rendering process.

### Understanding signals

Signals are like mutable variables, that point to one thing now and another thing in the future. 
They are made up of two primary functions:

* The **getter**, which allows you to read the current value of the signal.
* The *setter*, which enables you to alter or update the signal's value.

In Solid, the `createSignal` function can be used to generate a signal.
This function returns both the getter and setter as a pair in a two-element array.

```js=
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(1);

console.log(count()); // prints "1"

setCount(0); // Modifies the count value to 0

console.log(count()) // prints "0"
```

Here, `count` serves as the getter, and `setCount` functions as the setter.

### Effects

Effects are operations triggered by changes in one or more of the signals they depend on.
To create effects in Solid, there is the `createEffect` function.

```js=
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});
```

The effect takes a function that is re-invoked whenever any of the signals it relies on, such as `count`, undergoes a change.

## Building a reactive system

To grasp the concept of reactivity, it's often helpful to construct a reactive system from scratch. 

The following example will follow the observer pattern, where data entities (signals) will maintain a list of their subscribers (effects). When a signal changes, all the subscribers will be notified.

### Initial code structure

Here is a basic code outline to begin:

```jsx
function createSignal() {}

function createEffect() {}

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("The count is " + count());
});
```

### Implementing `createSignal`

The `createSignal` function performs two main tasks:
1. Initialize the value, in this case `count`, to 0.
2. Return an array with two elements: a getter and a setter function.

Implementation:

```tsx
function createSignal(initialValue) {
  let value = initialValue;
  
  function getter() {
    return value;
  }
  
  function setter(newValue) {
    value = newValue;
  }
  
  return [getter, setter];
}
```

This allows retrieval of the current value via the getter and modification through the setter. 
However, reactivity is not yet implemented.

### Implementing `createEffect`

The basic form of `createEffect` is simple:

```jsx
function createEffect(fn) {
  fn();
}
```

The core functionality emerges when linking `createSignal` and `createEffect`.

### Linking signals and effects

In order to introduce reactivity, you need the following steps:
1. Maintain a reference to the current subscriber function.
2. Register this function during effect creation.
3. Add the function to a subscriber list when accessing a signal.
4. Notify all the subscribers when updating a signal.

This can be shown as:

```jsx
let currentSubscriber = null;

function createSignal(initialValue) {
  let value = initialValue;
  const subscribers = new Set();
  
  function getter() {
    if (currentSubscriber) {
      subscribers.add(currentSubscriber);
    }
    return value;
  }
  
  function setter(newValue) {
    if (value === newValue) return;
    value = newValue;
    for (const subscriber of subscribers) {
      subscriber();
    }
  }
  
  return [getter, setter];
}

function createEffect(fn) {
  const initialSubscriber = currentSubscriber;
  currentSubscriber = fn;
  fn();
  currentSubscriber = initialSubscriber;
}
```

### Validating the reactive system

To validate the system, increment the `count` value at one-second intervals:

```jsxconst [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("The count is " + count());
});

setInterval(() => {
  setCount(count() + 1);
}, 1000);
```

This will display the incremented count value on the console at one-second intervals to confirm the reactive system's functionality.

## Managing lifecycles in a reactive system

In reactive systems, various elements, often referred to as "nodes", are interconnected. 
These nodes can be signals, effects, or other reactive primitives.
They serve as the individual units that collectively make up the reactive behavior of the system. 

When a node changes, the system will re-evaluate the parts connected to that node. 
This can result in updates, additions, or removals of these connections, affecting the overall behavior of the system.

Now, consider a scenario where a condition influences the data used to calculate an output:

```jsx
console.log("1. Initialize");
const [temperature, setTemperature] = createSignal(72);
const [unit, setUnit] = createSignal("Fahrenheit");
const [displayTemp, setDisplayTemp] = createSignal(true);

const displayTemperature = createMemo(() => {
  if (!displayTemp()) return "Temperature display is off";
  return `${temperature()} degrees ${unit()}`;
});

createEffect(() => console.log("Current temperature is", displayTemperature()));

console.log("2. Turn off displayTemp");
setDisplayTemp(false);

console.log("3. Change unit");
setUnit("Celsius");

console.log("4. Turn on displayTemp");
setDisplayTemp(true);
```

In this example, the `createMemo` primitive is used to cache the state of a computation. 
This means the computation doesn't have to be re-run if its dependencies remain unchanged.

The `displayTemperature` memo has an early return condition based on the value of `displayTemp`. 
When `displayTemp` is false, the memo returns a message saying "Temperature display is off," and as a result, `temperature` and `unit` are not tracked.

If the `unit` is changed while `displayTemp` is false, however, the effect won't trigger since none of the memo's current dependencies (`displayTemp` in this case) have changed.

### Synchronous nature of effect tracking

The reactivity system described above operates synchronously. 
This synchronous operation has implications for how effects and their dependencies are tracked. 
Specifically, the system registers the subscriber, runs the effect function, and then unregisters the subscriber â€” all in a linear, synchronous sequence.

Consider the following example:

```jsx
createEffect(() => {
  setTimeout(() => {
    console.log(count());
  }, 1000);
});
```

Here, the `createEffect` function initiates a `setTimeout`, which delays the call. 
Because the system is synchronous, it doesn't wait for this operation to complete. 
By the time the `count` getter is invoked within the `setTimeout`, the global scope no longer has a registered subscriber.
As a result, this `count` signal won't add the callback as a subscriber, leading to potential issues in tracking changes to count.

### Handling asynchronous effects

While the basic reactivity system is synchronous, frameworks like Solid offer more advanced features to handle asynchronous scenarios. 
For example, Solid provides the `on` function, which allows for manually specifying dependencies for an effect. 
This is particularly useful for ensuring that asynchronous operations are correctly tied into the reactive system. 

In addition to the `on` function, Solid introduces the concept of resources for managing asynchronous operations. 
Resources are specialized reactive primitives that convert the asynchronicity of operations like network requests into synchronicity, embedding the results within a signal. 
This allows the system to track asynchronous operations and their state, ensuring that the UI updates correctly when the asynchronous operation completes or its state changes.

Utilizing resources in Solid can help manage complex scenarios where multiple asynchronous operations are involved, and their completion might affect different parts of the reactive system. 
By integrating resources into the system, you can ensure that dependencies are correctly tracked and that the UI remains consistent with the underlying asynchronous data.