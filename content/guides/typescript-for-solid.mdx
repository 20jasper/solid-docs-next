import { Aside } from "~/components/configurable/Aside";

# TypeScript for Solid

## Overview

[TypeScript](https://www.typescriptlang.org/) is a superset of JavaScript that enhances code reliability and predictability through the introduction of [static types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html). 
While JavaScript code can be directly used in TypeScript, the added type annotations in TypeScript provide clearer code structure and documentation, making it more accessible for developers.

By leveraging standard JSX, Solid facilitates seamless TypeScript interpretation. 
Moreover, with Solid's built-in types for the API heighten accuracy. 

For developers eager to get started, we offer TypeScript templates on [GitHub](https://github.com/solidjs/templates/). 

## Configuring TypeScript

When integrating TypeScript with the Solid JSX compiler, there are crucial settings to make for a seamless interaction:

1. `"jsx": "preserve"` in the `tsconfig.json` retains the original JSX form. 
Solid's JSX transformation is incompatible with TypeScript's JSX transformation.
2. `"jsxImportSource": "solid-js"` designates SolidJS as the source of JSX types.

For a basic setup, your `tsconfig.json` should resemble:

```json
{
  "compilerOptions": {
    "jsx": "preserve",
    "jsxImportSource": "solid-js"
  }
}
```

For projects with diverse JSX sources, such as a blend of React and Solid, some flexibility does exist. 
While it's possible to set a default `jsxImportSource` in `tsconfig.json` which corresponds with the majority of your files, TypeScript also allows file-level overrides. 
Utilizing specific pragmas within `.tsx` files facilitates this:

```javascript
/** @jsxImportSource solid-js */
```
or, if using React:

```javascript
/** @jsxImportSource react */
```

Opting for the React JSX pragma means having React and its associated dependencies fully integrated into the project.
Furthermore, it makes sure the project's architecture is primed for React JSX file handling is vital.

## Migrating from JavaScript to TypeScript

Transitioning from JavaScript to TypeScript in a Solid project offers the benefits of static typing. Here are some of the key steps and considerations you should bear in mind during the migration:

1. Install TypeScript into your project.

```bash
npm install --save-dev typescript
```

2. Run `npx tsc --init` to generate a `tsconfig.json` file.

3. Update the contents of your `tsconfig.json` to match Solid's configuration:

```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client"],
    "noEmit": true,
    "isolatedModules": true
  }
}
```

4. Create a TypeScript or `.tsx` file to test the setup.

```typescript
import { type Component } from "solid-js";

function MyTsComponent(): JSX.Element {
  return (
    <div>
      <h1>This is a TypeScript component</h1>
    </div>
  );
}

export default MyTsComponent;
```

To use in an existing JavaScript component, import the TypeScript component:

```javascript
import MyTsComponent from "./MyTsComponent";

function MyJsComponent() {
  return (
    <>
      {/* ... */}
      <MyTsComponent />
    </>
  );
}
```

<Aside>
**Note:** If you wish to change the entry point file from `index.jsx` to `index.tsx`, you need to modify the `src` attribute in `<script>` to look like the following:

```htmlembedded
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- ... -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="/src/index.tsx" type="module"></script>
  </body>
</html>
```
</Aside>

## API types

Solid is written in TypeScript, meaning everything is typed out of the box.

The [API Documentation](/references) details the types of all the API calls. 
In addition, there are several helpful type definitions to make it easier when you need to specify explicit types.

### Signals

Using `createSignal<T>`, you can define the signal's type as `T`. 

```typescript
const [count, setCount] = createSignal<number>();
```

Here, `createSignal` has the return type `Signal<number | undefined>`, corresponding to the type passed into it, and `undefined` as it was uninitialized. 
This resolves to a getter-setter [tuple](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types), both of which are generically typed:

```typescript
import type { Signal, Accessor, Setter } from "solid-js";
type Signal<T> = [get: Accessor<T>, set: Setter<T>];
```

In Solid, a signal's getter, like `count`, is essentially a function that returns a specific type. 
In this case, the type is `Accessor<number | undefined>`, which translates to a function `() => number | undefined`. 
Since the signal was not initialized, its initial state is `undefined`, therefore `undefined` is included in its type.

The corresponding setter, `setCount`, has a more complex type: `Setter<number | undefined>`. 
This type can be roughly understood as a function that takes either a direct number or another function as its argument. 
This function argument, in turn, can take the previous value of the signal and return a new value. 
Both the input and output can be either a number or `undefined`. 
Notably, invoking `setCount` without any parameters will set the signal's value to `undefined`.

When using the function form of the setter, a single argument is provided, which can be ignored if desired.
Additionally, the return type of the setter will align with the type of value passed into it, echoing the behavior expected from a typical assignment operation.

If a signal is intended to store functions, the setter won't directly accept new functions as values. 
This is because it can not distinguish whether the function should be executed to yield the actual value or stored as is. 
In these situations, using the callback form of the setter is recommended: `setSignal(() => value)`.


#### Default values

By providing default values when you call `createSignal`, you can avoid the need for explicit type specification and eliminate the possibility of the `| undefined` type. 
This leverages type inference to determine the type automatically:

```typescript
const [count, setCount] = createSignal(0);
const [name, setName] = createSignal("");
```

In this example, TypeScript understands the types as `number` and `string`.
This means that `count` and `name` directly receive the types `Accessor<number>` and `Accessor<string>`, respectively, without the `| undefined` tag.

### Context

Just as signals utilize `createSignal<T>`, context uses `createContext<T>`, which is parameterized by the type `T` of the context's value:

```tsx
type Data = { count: number; name: string };
```

When you invoke `useContext(dataContext)`, it returns the type contained within the context. 
For example, if the context is of type `Context<Data | undefined>`, then using `useContext` with it will naturally yield a result of type `Data | undefined`. 
The `| undefined` part signifies that the context may not be defined in the component's ancestor hierarchy.

`dataContext` will be understood as `Context<Data | undefined>`. 
Invoking `useContext(dataContext)` mirrors this type, returning `Data | undefined`.
The `| undefined` arises since it cannot be determined if the context's value will be used in a where it has been assigned. 

Much like what was seen with [default values](#default-values) in signals, `| undefined` can be avoided in the type by giving a default value that will be returned if no value is assigned by a context provider.

```typescript
const dataContext = createContext({ count: 0, name: "" });
```

By providing a default value, TypeScript determines that `dataContext` is `Context<{ count: number, name: string }>`.
This is equivalent to `Context<Data>` but without `| undefined`. 

A common approach to this is forming a factory function to generate a context's value. 
By using TypeScript's [`ReturnType`](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations), the return type of this function can be used to type this context:

```tsx
export const makeCountNameContext = (initialCount = 0, initialName = "") => {
  const [count, setCount] = createSignal(initialCount);
  const [name, setName] = createSignal(initialName);
  return [
    { count, name },
    { setCount, setName },
  ] as const;
};

type CountNameContextType = ReturnType<typeof makeCountNameContext>;
export const CountNameContext = createContext<CountNameContextType>();
```

`CountNameContextType` will correspond to the result of `makeCountNameContext`:

```tsx
[
  {readonly count: Accessor<number>, readonly name: Accessor<string>},
  {readonly setCount: Setter<number>, readonly setName: Setter<string>}
]
```

To retrieve the context use `useCountNameContext`, which has a type signature of `() => CountNameContextType | undefined`.

In scenarios where you may wish to avoid `undefined` as a possible type, you can assert that the context will always be present
Additionally, throwing a readable error may be preferable to non-null asserting:

```tsx
export const useCountNameContext = () => {
  const countName = useContext(CountNameContext);
  if (!countName) {
    throw new Error("useCountNameContext should be called inside its ContextProvider");
  }
  return countName;
}
```

**Note:** While supplying a default value to `createContext` can make the context perpetually defined, this approach may not always be advisable. Depending on the use case, it could lead to silent failures, which may be less preferable.

### Components

#### The basics

By default, components in Solid use the generic `Component<P>` type, where `P` represents the props' type that is an object.

```tsx
import type { Component } from "solid-js";

const MyComponent: Component<MyProps> = (props) => {
    ...
}
```

A `JSX.Element` denotes anything renderable by Solid, which could be a DOM node, array of JSX elements, or functions yielding `JSX.Element`.

For a simple example, here's a counter:

```tsx
const Counter: Component = () => {
  const [count, setCount] = createSignal(0);
  return <button onClick={() => setCount(c => c + 1)}>{count()}</button>;
};
```

Trying to pass unneccessary props or children will result in type errors:

```tsx
<Counter />;  // ✔️
<Counter initial={5} />;  // ❌: No 'initial' prop defined
<Counter>hi</Counter>;  // ❌: Children aren't expected
```

#### Components with props

For components that require the use of props, they can be typed using [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content):

```tsx
const InitCounter: Component<{ initial: number }> = (props) => {
  const [count, setCount] = createSignal(props.initial);
  return <button onClick={() => setCount((c) => c + 1)}>{count()}</button>;
};

<InitCounter initial={5} />;
```

#### Components with children

Often, components may need to accept child elements.
For this, Solid provides `ParentComponent` that includes `children?` as an optional prop.
If defining a component with the `function` keyword, `ParentProps` can be used as a helper for the props:

```tsx
import { ParentComponent } from "solid-js";

const CustomCounter: ParentComponent = (props) => {
  const [count, setCount] = createSignal(0);
  return (
    <button onClick={() => setCount((c) => c + 1)}>
      {count()}
      {props.children}
    </button>
  );
};
```

In this example, `props` is inferred to be of the type `{children?: JSX.Element }`, streamlining the process of defining components that can accept children.

#### Special component types

Solid offers subtypes for components dealing uniquely with children:

##### Components without the `Component` types

Using the `Component` types is a matter of preference over a strict requirement.
Any function that takes props and returns a JSX.Element qualifies as a valid component.

```tsx 
// arrow function 
const MyComponent = (props: MyProps): JSX.Element => { ... }

// function declaration 
function MyComponent(props: MyProps): JSX.Element { ... }

// component which takes no props 
function MyComponent(): JSX.Element { ... }
```

It is worth noting that if you want to create a generic component, the `Component` types will **not** be applicable. 
Instead, you will need to define your generics explicitly:

```tsx
// For arrow functions, the syntax <T> by itself is invalid in TSX because it could be confused with JSX.
const MyGenericComponent = <T extends unknown>(props: MyProps<T>): JSX.Element => { /* ... */ }

// Using a function declaration for a generic component
function MyGenericComponent<T>(props: MyProps<T>): JSX.Element { /* ... */ }

```

<Aside>
Each `Component` type has a corresponding `Props` type that defines the shape of its properties. 
These `Props` types also accept the same generic types as their associated `Component` types.
</Aside>

### Event handling

#### Basics

In Solid, the type for event handlers is specified as `JSX.EventHandler<TElement, TEvent>`.
Here, `TElement` refers to the type of the element the event is linked to, and `TEvent` indicates the type of the event itself. 
You can opt to use this type in your code as an alternative to `(event: TEvent) => void`. 
Doing this will ensure that `currentTarget` and `target` are accurately typed within the event object and also allow you to avoid using inline event handlers.

```typescript
import type { JSX } from "solid-js";

// Here's how to define an event handler using the `EventHandler` type:
const onInput: JSX.EventHandler<HTMLInputElement, InputEvent> = (event) => {
    console.log("Input changed to", event.currentTarget.value);
};

// You can then attach this handler to an input element:
<input onInput={onInput} />;
```

#### Inline handlers

When you define an event handler inline with a JSX attribute, the handler is automatically typed for you.
This means you get the type inference and checking without any additional work:

```tsx
<input
    onInput={(event) => {
        console.log("Input changed to", event.currentTarget.value);
    }}
/>
```

#### `currentTarget` and `target`

In the context of event delegation, the difference between `currentTarget` and `target` is important:

* `currentTarget`: Represents the DOM element that the event handler is attached to.
* `target`: Any DOM element within the hierarchy of `currentTarget` that has initiated the event.

While `currentTarget` will always be of type `T` as defined by `JSX.EventHandler<T, E>`, the `target` type can be more general, such as ny DOM element. 
However, when it comes to specific events such as `Input` and `Focus` events directly attached to input elements, `target` will be typed as `HTMLInputElement`.

### `ref` attribute

#### Basics

In a non-TypeScript setting, when you utilize the `ref` attribute, Solid assigns the associated DOM element to the variable once rendered:

```javascript
let divRef;
console.log(divRef); // Outputs: undefined
onMount(() => {
  console.log(divRef); // Outputs: <div> element
});
return <div ref={divRef} />;
```

With TypeScript, however, especially under strict `null` checks, typing such variables can be a challenge.

A safe TypeScript pattern is to accept that `divRef` can be `undefined` initially, and then enforce checks when accessing it:

```typescript
let divRef: HTMLDivElement | undefined;
// This would be flagged as an error during compilation
divRef.focus(); 
onMount(() => {
  if (!divRef) return;
  divRef.focus(); 
});
return <div ref={divRef}>...</div>;
```

In the context of the [`onMount`](/reference/onMount) function, since it's executed post-render, a non-`null` assertion (!) can be used:

```typescript
onMount(() => {
  divRef!.focus();
});
```

An alternative pattern is to avoid `null` at the assignment level, and then use a definite assignment assertion in the `ref` attribute:

```typescript
let divRef: HTMLDivElement;
// Compilation error as expected
divRef.focus(); 
onMount(() => {
  divRef.focus(); 
});
return <div ref={divRef!}>...</div>;
```

Here, the `divRef!` in the `ref` attribute informs TypeScript that `divRef` will be assigned after this point, aligning more with Solid's behavior.

<Aside>
  **Caution**: Although TypeScript flags erroneous use of `ref`s before they're defined in the JSX block, it doesn't currently flag undefined variables within certain nested functions in Solid. 
  Thus, extra care is needed when using `ref`s within functions like [`createMemo`](/reference/createMemo), [`createRenderEffect`](/reference/createRenderEffect), and [`createComputed`](/reference/createComputed).
</Aside>

Lastly, there's a less-safe pattern where the definite assignment assertion is declared right when the variable is initialized.
This technique bypasses TypeScript's assignment checks for that specific variable, providing a quick workaround at the cost of potential runtime errors.

```typescript
let divRef!: HTMLDivElement;
// This will be permitted but will throw an error at runtime
divRef.focus();
onMount(() => {
  divRef.focus(); 
});
return <div ref={divRef}>...</div>;
```

## Control flow narrowing

When using control flow components in Solid, such as [`<Show>`](/reference/show), it's common to conditionally display content based on the presence of certain data.
This, however, can introduce some type-checking challenges, especially when attempting to manipulate the daata within these components.

Consider a situation where you want to show a name only when it's defined using a Solid signal:

```typescript
const [name, setName] = createSignal<string>();
return (
  <Show when={(() => {
      const v = data()
      return v && v.type === "user" && v // T: User | undefined
    })()}>
  )
```

Accessing the callback may throw an error if the `when` prop is nullish or false at the time of access.
Usually this is not the case, however in `onCleanup` or asynchronous contexts it can be.

TypeScript may not like this.
While you can understand that the second call to `name()` happens only if the first is truthy, TypeScript cannot. 
It may flag an error indicating that `name()` could potentially be `undefined` when `.replace()` is called.

There are a few ways to tackle this:

1. **Non-Null Assertion**
Use TypeScript's [non-null assertion operator (!).](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-) 
This operator tells TypeScript you're confident the value isn't `null` or `undefined`:

```typescript
return <Show when={name()}>Hello {name()!.replace(/\s+/g, "\xa0")}!</Show>;
```
While this may be a quick option, incorrectly asserting can lead to runtime errors if the value does turn out to be `null` or `undefined`.

2. **Callback form of Show**

Solid provides a callback form for its [`<Show>`](/reference/show) component. 
In this form, the value that makes the when prop true is passed into the component:

```typescript
const [data, setData] = createSignal<User | Admin>() // T: Signal<User | Admin | undefined>

return(
    <Show when={(() => {
      const v = data()
      return v && v.type === "user" && v // T: User | undefined
    })()}>
  )
```

This approach takes advantage of the type information embedded in the [`<Show>`](/reference/show) component. 
By temporarily storing the value `v`, you can use type narrowing to specify its type more accurately before returning it.

You do have to be cautious, however, since accessing the callback may throw an error if the when prop is nullish or false at the time of access. 
This is usually not an issue, but in asynchronous contexts or during [`onCleanup`](/reference/oncleanup), it may occur.

<Aside>
If you find the above method a bit shorthand, there's a more explicit alternative. 
Solid's [`<Show>`](/reference/show) component actually performs memoization, so you don't necessarily need a memo for this:

```tsx
const user = createMemo(() => {
  const v = data()
  return v && v.type === "user" && v // Type: User | undefined
})

<Show when={user()}>
  {user => <User user={user()} />}
</Show>
```
While this approach is more explicit, it's worth noting that the primary example for the callback form should ideally not use this technique for the sake of clarity
</Aside>

## Advanced JSX attributes and directives

### Custom event handlers

For custom events in Solid, the [`on:___`]() and [`oncapture:___`]() attributes can be utilized. 
To type these events, you'll need to extend Solid's JSX namespace.

```tsx
class NameEvent extends CustomEvent {
  type: "Name";
  detail: { name: string };

  constructor(name: string) {
    super("Name", { detail: { name } });
  }
}

declare module "solid-js" {
  namespace JSX {
    interface CustomEvents {
      Name: NameEvent;  // Matches `on:Name`
    }
    interface CustomCaptureEvents {
      Name: NameEvent;  // Matches `oncapture:Name`
    }
  }
}

// Usage
<div on:Name={(event) => console.log("name is", event.detail.name)} />;
```

<Aside>
**Note**: By default, using native events like `mousemove` with the `on` prefix (e.g., <div on:mousemove={e => {}} />) will result in a TypeScript error. 
This is because they are not included in the custom event typings for Solid.
To solve this, extend the `CustomEvents` and `CustomCaptureEvents` interfaces to include events from the `HTMLElementEventMap`:

To include all native events:

```typescript
declare module "solid-js" {
  namespace JSX {
    interface CustomEvents extends HTMLElementEventMap {}
    interface CustomCaptureEvents extends HTMLElementEventMap {}
  }
}
```

To include specific native events, you can pick certain events (e.g. `mousemove` and `pointermove`):

```typescript
declare module "solid-js" {
  namespace JSX {
    interface CustomEvents extends Pick<HTMLElementEventMap, "mousemove" | "pointermove"> {}
  }
}
```
</Aside>

#### Forcing properties and custom attributes 

Solid's [`prop:___`]() allows forcing properties, while [`attr:___`]() permits custom attributes. 

```typescript
declare module "solid-js" {
  namespace JSX {
    interface ExplicitProperties {
      count: number;
      name: string;
    }
    interface ExplicitAttributes {
      count: number;
      name: string;
    }
  }
}

// Usage
<Input prop:name={name()} prop:count={count()}/>
<my-web-component attr:name={name()} attr:count={count()}/>
```

#### Custom directives

Custom directives can be applied using the [`use:___`]() attribute.
These directives typically accept two arguments: the target element or component, and the value passed to them by the JSX attribute.
While the conventional `Directives` interface focuses on type-checking the value, which is the second argument, there are additional considerations:

* A single accessor is always received, limiting the ability to pass in multiple arguments. 
The closest appropximation is to use syntax such as `<div use:foo={["string", "array"]} />`.
* The behaviour of TypeScript's type checking for module augmentation allows `DirectiveFunctions` to potentially accept functions that do not strictlly meet the type requirements.

```tsx
function model(
  element: Element, // directives can be used on any HTML and SVG element
  value: Accessor<Signal<string>> // second param will always be an accessor in case value being reactive
) {
  const [field, setField] = value();
  createRenderEffect(() => (element.value = field()));
  element.addEventListener("input", (e) => {
    const value = (e.target as HTMLInputElement).value;
    setField(value);
  });
}

declare module "solid-js" {
  namespace JSX {
    interface Directives {
      model: Signal<string>;  // Corresponds to `use:model`
    }
  }
}

// Usage
let [name, setName] = createSignal("");
<input type="text" use:model={[name, setName]} />;
```

In using `DirectiveFunctions`, there's the ability to check both arguments (if present) by detailing the entire function type

```tsx
function model(element: HTMLInputElement, value: Accessor<Signal<string>>) {
  const [field, setField] = value();
  createRenderEffect(() => (element.value = field()));
  element.addEventListener("input", (e) => setField(e.target.value));
}

function log(element: Element) {
  console.log(element);
}

let num = 0;
function count() {
  num++;
}

function foo(comp: Element, args: Accessor<string[]>) {
  // function body
}

declare module "solid-js" {
  namespace JSX {
    interface DirectiveFunctions {
      model: typeof model;
      log: typeof log;
      count: typeof count;
      foo: typeof foo;
    }
  }
}
```

Although the `Directives` interface can be employed to restrict the value passed to the directive as a JSX attribute, using `DirectiveFunctions` ensures both the element and value align with the expected types.

```tsx
{/* This is correct */}
<input use:model={createSignal('')} />

{/* These are incorrect */}
<input use:model />
<input use:model={7} />
<div use:model={createSignal('')} />
```

##### Addressing import issues with directives

When using directives imported from another file/module, TypeScript may eliminate the import if it mistakenly perceives it as a type. 

* Set the `onlyRemoveTypeImports: true` option in `babel-preset-typescript`. 
If using `vite-plugin-solid`, this can be configured with `solidPlugin({ typescript: { onlyRemoveTypeImports: true } })` in `vite.config.ts`. 
However, this approach mandates judicious use of `export type` and `import type`.
* Including a statement in the importing module ensures TypeScript retains the directive's import, as seen below.
[Tree-shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) tools will typically exclude this code from the final bundle.

```tsx
import { directive } from "./directives.js"

directive // prevents TypeScript's tree-shaking

<div use:directive />
```