import { Aside } from "~/components/configurable/Aside";

# TypeScript for Solid

## Overview

[TypeScript](https://www.typescriptlang.org/) is a superset of JavaScript that enhances code reliability and predictability through the introduction of [static types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html). 
While JavaScript code can be directly used in TypeScript, the added type annotations in TypeScript provide clearer code structure and documentation, making it more accessible for developers.

By leveraging standard JSX, Solid facilitates seamless TypeScript interpretation. 
Moreover, with Solid's built-in types for the API heighten accuracy. 

For developers eager to get started, we offer TypeScript templates our [GitHub](https://github.com/solidjs/templates/). 

## Configuring TypeScript

When integrating TypeScript with the Solid JSX compiler, there are crucial settings to make for a seamless interaction:

1. `"jsx": "preserve"` in the `tsconfig.json` retains the original JSX form.
2. `"jsxImportSource": "solid-js"` designates SolidJS as the source of JSX types.

For a basic setup, your `tsconfig.json` should resemble:

```json
{
  "compilerOptions": {
    "jsx": "preserve",
    "jsxImportSource": "solid-js"
  }
}
```

For projects with diverse JSX sources, such as a blend of React and Solid, some flexibility does exist. 
While it's possible to set a default `jsxImportSource` in `tsconfig.json` to corresponds with the majority of your files, TypeScript also allows file-level overrides. 
Utilizing specific pragmas within `.tsx` files facilitates this:

```javascript
/** @jsxImportSource solid-js */
```
or, if using React:

```javascript
/** @jsxImportSource react */
```

Opting for the React JSX pragma means having React and its associated dependencies fully integrated into the project.
Furthermore, it makes sure the project's architecture is primed for React JSX file handling is vital.

## Migrating from JavaScript to TypeScript

Transitioning from JavaScript to TypeScript in a Solid project offers the benefits of static typing. Here are some of the key steps and considerations you should bear in mind during the migration:

1. Install TypeScript into your project.

```bash
npm install --save-dev typescript
```

2. Run `npx tsc --init` to generate a `tsconfig.json` file.

3. Update the contents of your `tsconfig.json` to match Solid's configuration:

```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client"],
    "noEmit": true,
    "isolatedModules": true
  }
}
```

4. Create a TypeScript or `.tsx` file to test the setup.

```typescript
import { Component } from "solid-js";

function MyTsComponent(): Component {
  return (
    <div>
      <h1>This is a TypeScript component</h1>
    </div>
  );
}

export default MyTsComponent;
```

To use in an existing JavaScript component, import the TypeScript component:

```javascript
import MyTsComponent from "./MyTsComponent";

function MyJsComponent() {
  return (
    <>
      {/* ... */}
      <MyTsComponent />
    </>
  );
}
```

<Aside>
**Note:** If you wish to change the entry point file from `index.jsx` to `index.tsx`, you need to modify the `src` attribute in `<script>` to look like the following:

```htmlembedded
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- ... -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="/src/index.tsx" type="module"></script>
  </body>
</html>
```
</Aside>

## API types

Solid is written in TypeScript, meaning everything is typed out of the box.

The [API Documentation](/references) details the types of all the API calls. 
In addition, there are several helpful type definitions to make it easier when you need to specify explicit types.

### Signals

Using `createSignal<T>`, you can define the signal's type as `T`. 

```typescript
const [count, setCount] = createSignal<number>();
```

Here, `createSignal` has the return type `Signal<number>`, corresponding to the type passed into it.
This resolves to a getter-setter [tuple](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types), both of which are generically typed:

```typescript
import type { Signal, Accessor, Setter } from "solid-js";
type Signal<T> = [get: Accessor<T>, set: Setter<T>];
```

In this instance, the signal getter, `count`, assumes a type `Accessor<number | undefined>`. 
This denotes Solid's type `Accessor<T>`, mapping to `() => number | undefined`. 
The `| undefined` is attributed to the lack of efault value in `createSignal`, leading to the signal's initial undefined state.

The signal setter, `setCount`, is of type `Setter<number>`. 
This complex type roughly resembles `(value? : number | ((prev?: number) => number)) => number`, accommodating both a direct number or a function which takes a potential pervious value that results in a number.
Since the signal's start is undefined, both the direct number and the function's number parameter are optional.

Typescript errors can present with parameter assignments, such as `setcount(value)`. 
To make sure `value` isn't mistaken for a function, you can use `setCount(() => value)`. 

#### Default values

Defining default values when invoking `createSignal` can sidestep explicit type specification and removes the potential `| undefined` type:

```typescript
const [count, setCount] = createSignal(0);
const [name, setName] = createSignal("");
```

In this example, TypeScript understands the types as `number` and `string`.
This means that `count` and `name` directly receive the types `Accessor<number>` and `Accessor<string>`, respectively, without the `| undefined` tag.

### Context

Just as signals utilize `createSignal<T>`, context uses `createContext<T>`, which is parameterized by the type `T` of the context's value:

```typescript
type Data = { count: number; name: string };
const dataContext = createContext<Data>();
```

`dataContext` is understood as `Context<Data | undefined>`. 
Invoking `useContext(dataContext)` mirrors this type, returning `Data | undefined`.
The `| undefined` arises when context is not defined in the component's ancestors, which leads `useContext` to yield `undefined`.

Much like what was seen the [default values](#default-values) in signals, you can avoid the `| undefined` in the type through explicity type definitions to avoid redudancy:

```typescript
const dataContext = createContext({ count: 0, name: "" });
```

By providing a default value, TypeScript determines that `dataContext` is `Context<{ count: number, name: string }>` -- equivalent to `Context<Data>` without the `| undefined`. 

A common approach is forming a factory function to generate a context's value. By using TypeScripts [`ReturnType`](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#return-type-annotations), the return type of this function can be used to type this context:

```typescript
export const makeCountNameContext = (initialCount = 0, initialName = "") => {
  const [count, setCount] = createSignal(initialCount);
  const [name, setName] = createSignal(initialName);
  return [
    { count, name },
    { setCount, setName },
  ] as const;
};

type CountNameContextType = ReturnType<typeof makeCountNameContext>;
export const CountNameContext = createContext<CountNameContextType>();
```

`CountNameContextType` corresponds to the result of `makeCountNameContext`:

```typescript
[
  {readonly count: Accessor<number>, readonly name: Accessor<string>},
  {readonly setCount: Setter<number>, readonly setName: Setter<string>}
]
```

To retrieve the context, using `useCountNameContext` which has aa type signature of `() => CountNameContextType | undefined`.

In scenarios where you may wish to avoid `undefined` as a possible type, you can assert that the context will always be present:

```typescript
export const useCountNameContext = () => useContext(CountNameContext)!;
```

**Note:** A more secure route is to supply a default value to `createContext` to make sure that context is perpetually defined.

### Components

#### The basics

By default, components in Solid use the generic `Component<P>` type, where `P` represents the props' type that is an object.

```typescript
import type { JSX, Component } from "solid-js";

type Component<P = {}> = (props: P) => JSX.Element;
```

A `JSX.Element` denotes anything renderable by Solid, which could be a DOM node, array of JSX elements, or functions yielding `JSX.Element`.

For a simple example, here's a counter:

```typescript
const Counter: Component = () => {
  const [count, setCount] = createSignal(0);
  return <button onClick={() => setCount((c) => c + 1)}>{count()}</button>;
};
```

Trying to pass unneccessary props or children will result in type errors:

```typescript
<Counter />;  // ✔️
<Counter initial={5} />;  // ❌: No 'initial' prop defined
<Counter>hi</Counter>;  // ❌: Children aren't expected
```

#### Components with props

For components that require the use of props, they can be typed using [generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content):

```typescript
const InitCounter: Component<{ initial: number }> = (props) => {
  const [count, setCount] = createSignal(props.initial);
  return <button onClick={() => setCount((c) => c + 1)}>{count()}</button>;
};

<InitCounter initial={5} />;
```

#### Components with children

Often, components may need to accept child elements.
For this, Solid provides `ParentComponent` that includes `children?` as an optional prop.
If defining a component with the `function` keyword, `ParentProps` can be used as a helper for the props:

```typescript
import { JSX, ParentComponent, ParentProps } from "solid-js";

type ParentProps<P = {}> = P & { children?: JSX.Element };

const CustomCounter: ParentComponent = (props) => {
  const [count, setCount] = createSignal(0);
  return (
    <button onClick={() => setCount((c) => c + 1)}>
      {count()}
      {props.children}
    </button>
  );
};
```

In this example, `props` is inferred to be of the type `{children?: JSX.Element }`, streamlining the process of defining components that can accept children.

#### Special component types

Solid offers subtypes for components dealing uniquely with children:

* **VoidComponent:** when a component should not accept children.
* **FlowComponent:** designed for components like [`<Show>`](/reference/Show) or [`<For>`](/reference/For), typically requiring children and, occasionally, specific children types.

These types make sure that the children are present and fit the required type, maintaining consistent component behaviour.

### Event handling

#### Basics

The `JSX.EventHandler<T, E>` type allows you to define event handlers for a specific DOM element type `T` and event type `E.` 
This provides the event handler function with events of the right type and makes sure it interacts correctly with elements of the expected type.

```typescript
import type { JSX } from "solid-js";

// Here's how to define an event handler using the `EventHandler` type:
const onInput: JSX.EventHandler<HTMLInputElement, InputEvent> = (event) => {
    console.log("Input changed to", event.currentTarget.value);
};

// You can then attach this handler to an input element:
<input onInput={onInput} />;
```

#### Inline handlers

When you define an event handler inline with a JSX attribute, Solid automatically types the handler for you.
This means you get the type inference and checking without any additional work:

```typescript
<input
    onInput={(event) => {
        console.log("Input changed to", event.currentTarget.value);
    }}
/>
```

#### `currentTarget` and `target`

In the context of event delegation, the difference between `currentTarget` and `target` is important:

* `currentTarget`: Represents the DOM element that the event handler is attached to.
* `target`: Any DOM element within the heirarchy of `currentTarget` that has initiated the event.

While `currentTarget` will always be of type `T` as defined by `JSX.EventHandler<T, E>`, the `target` type can be more general, such as ny DOM element. However, when it comes to specific events such as `Input` and `Focus` events directly attached to input elements, `target` must be typed as `HTMLInputElement`.

### `ref` attribute

#### Basics

In a non-TypeScript setting, when you utilize the `ref` attribute, Solid assigns the associated DOM element to the variable once rendered:

```javascript
let divRef;
console.log(divRef); // Outputs: undefined
onMount(() => {
  console.log(divRef); // Outputs: <div> element
});
return <div ref={divRef} />;
```

With TypeScript, however, especially under strict `null` checks, typing such variables can be a challenge.

A safe TypeScript pattern is to accept that `divRef` can be `undefined` initially, and then enforce checks when accessing it:

```typescript
let divRef: HTMLDivElement | undefined;
// This would be flagged as an error during compilation
divRef.focus(); 
onMount(() => {
  if (!divRef) return;
  divRef.focus(); 
});
return <div ref={divRef}>...</div>;
```

In the context of the [`onMount`](/reference/onMount) function, since it's executed post-render, a non-`null` assertion (!) can be used:

```typescript
onMount(() => {
  divRef!.focus();
});
```

An alternative pattern is to avoid `null` at the assignment level, and then use a definite assignment assertion in the `ref` attribute:

```typescript
let divRef: HTMLDivElement;
// Compilation error as expected
divRef.focus(); 
onMount(() => {
  divRef.focus(); 
});
return <div ref={divRef!}>...</div>;
```

Here, the `divRef!` in the `ref` attribute informs TypeScript that `divRef` will be assigned after this point, aligning more with Solid's behavior.

<Aside>
  **Caution**: Although TypeScript flags erroneous use of `ref`s before they're defined in the JSX block, it doesn't currently flag undefined variables within certain nested functions in Solid. 
  Thus, extra care is needed when using `ref`s within functions like [`createMemo`](/reference/createMemo), [`createRenderEffect`](/reference/createRenderEffect), and [`createComputed`](/reference/createComputed).
</Aside>

Lastly, there's a less-safe pattern where the definite assignment assertion is declared right when the variable is initialized.
This technique bypasses TypeScript's assignment checks for that specific variable, providing a quick workaround at the cost of potential runtime errors.

```typescript
let divRef!: HTMLDivElement;
// This will be permitted but will throw an error at runtime
divRef.focus();
onMount(() => {
  divRef.focus(); 
});
return <div ref={divRef}>...</div>;
```

## Control flow narrowing

When using control flow components in Solid, such as [`<Show>`](/reference/show), it's common to conditionally display content based on the presence of certain data.
This, however, can introduce some type-checking challenges, especially when attempting to manipulate the daata within these components.

Consider a situation where you want to show a name only when it's defined using a Solid signal:

```typescript
const [name, setName] = createSignal<string>();
return <Show when={name()}>Hello {name().replace(/\s+/g, "\xa0")}!</Show>;
```

TypeScript may not like this.
While you can understand that the second call to `name()` happens only if the first is truthy, TypeScript cannot. 
It may flag an error indicating that `name()` could potentially be `undefined` when `.replace()` is called.

There are a few ways to tackle this:

1. **Non-Null Assertion**
Use TypeScript's [non-null assertion operator (!).](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-) 
This operator tells TypeScript you're confident the value isn't `null` or `undefined`:

```typescript
return <Show when={name()}>Hello {name()!.replace(/\s+/g, "\xa0")}!</Show>;
```
While this may be a quick option, incorrectly asserting can lead to runtime errors if the value does turn out to be `null` or `undefined`.

2. **Callback form of Show**

Solid offers a callback form for the [`<Show>`](/reference/show) component, where the truthy value of the `when` prop gets passed in:

```typescript
const [data, setData] = createSignal<User | Admin>() // T: Signal<User | Admin | undefined>

return(
    <Show when={() => {
      const v = data()
      return v && v.type === "user" && v // T: User | undefined
    })}>
      {user => <User user={user()} />}
    </Show>
  )
```

This method leverages the type information embedded in the [`<Show>`](/reference/show) component.
TypeScript can infer that since `n` comes from a truthy `name()`, it can't be `undefined` or other falsy values.
However, accessing this null asserted form incorrectly may thrown an error if the condition is not satisfied.

## Advanced JSX attributes and directives

### Custom event handlers

For custom events in Solid, the [`on:___`]() and [`oncapture:___`]() attributes can be utilized. 
To type these events, you'll need to extend Solid's JSX namespace.

```typescript
class NameEvent extends CustomEvent {
  type: "Name";
  detail: { name: string };

  constructor(name: string) {
    super("Name", { detail: { name } });
  }
}

declare module "solid-js" {
  namespace JSX {
    interface CustomEvents {
      Name: NameEvent;  // Matches `on:Name`
    }
    interface CustomCaptureEvents {
      Name: NameEvent;  // Matches `oncapture:Name`
    }
  }
}

// Usage
<div on:Name={(event) => console.log("name is", event.detail.name)} />;
```

<Aside>
**Note**: By default, using native events like `mousemove` with the `on` prefix (e.g., <div on:mousemove={e => {}} />) will result in a TypeScript error. 
This is because they are not included in the custom event typings for Solid.
To solve this, extend the `CustomEvents` and `CustomCaptureEvents` interfaces to include events from the `HTMLElementEventMap`:

To include all native events:

```typescript
declare module "solid-js" {
  namespace JSX {
    interface CustomEvents extends HTMLElementEventMap {}
    interface CustomCaptureEvents extends HTMLElementEventMap {}
  }
}
```

To include specific native events, you can pick certain events (e.g. `mousemove` and `pointermove`):

```typescript
declare module "solid-js" {
  namespace JSX {
    interface CustomEvents extends Pick<HTMLElementEventMap, "mousemove" | "pointermove"> {}
  }
}
```
</Aside>

#### Forcing properties and custom attributes 

Solid's [`prop:___`]() allows forcing properties, while [`attr:___`]() permits custom attributes. 

```typescript
declare module "solid-js" {
  namespace JSX {
    interface ExplicitProperties {
      count: number;
      name: string;
    }
    interface ExplicitAttributes {
      count: number;
      name: string;
    }
  }
}

// Usage
<Input prop:name={name()} prop:count={count()}/>
<my-web-component attr:name={name()} attr:count={count()}/>
```

#### Custom directives

Custom directives can be applied using the [`use:___`]() attribute.
These directives typically accept two arguments: the element or component they are applied to, and the value passed to them as a JSX attribute.
The conventional `Directives` interface only facilitates checking the value, i.e., the second argument. 

```tsx
function model(
  element: Element, // directives can be used on any HTML and SVG element
  value: Accessor<Signal<string>> // second param will always be an accessor in case value being reactive
) {
  const [field, setField] = value();
  createRenderEffect(() => (element.value = field()));
  element.addEventListener("input", (e) => {
    const value = (e.target as HTMLInputElement).value;
    setField(value);
  });
}

declare module "solid-js" {
  namespace JSX {
    interface Directives {
      model: Signal<string>;  // Corresponds to `use:model`
    }
  }
}

// Usage
let [name, setName] = createSignal("");
<input type="text" use:model={[name, setName]} />;
```

In using `DirectiveFunctions`, there's the ability to check both arguments (if present) by detailing the entire function type:

```tsx
function model(element: HTMLInputElement, value: Accessor<Signal<string>>) {
  const [field, setField] = value();
  createRenderEffect(() => (element.value = field()));
  element.addEventListener("input", (e) => setField(e.target.value));
}

function log(element: DOMElement) {
  console.log(element);
}

let num = 0;
function count() {
  num++;
}

function foo(comp: number, ...args: string[]) {
}

declare module "solid-js" {
  namespace JSX {
    interface DirectiveFunctions {
      model: typeof model;
      log: typeof log;
      count: typeof count;
      foo: typeof foo;
    }
  }
}
```

Although the `Directives` interface can be employed to check the value passed as a JSX aattribute, using `DirectiveFunctions` provides enhanced type-checking capabilities, ensuring both the element/component and value align with the exepcted types.

```tsx
{/* This is correct */}
<input use:model={createSignal('')} />

{/* These are incorrect */}
<input use:model />
<input use:model={7} />
<div use:model={createSignal('')} />
```

##### Addressing import issues with directives

When using directives imported from another file/module, TypeScript may eliminate the import if it mistakenly perceives it as a type. 

* Set the `onlyRemoveTypeImports: true` option in `babel-preset-typescript`. 
If using `vite-plugin-solid`, this can be configured with `solidPlugin({ typescript: { onlyRemoveTypeImports: true } })` in `vite.config.ts`. 
However, this approach mandates judicious use of `export type` and `import type`.
* Including a statement in the importing module ensures TypeScript retains the directive's import, as seen below.
[Tree-shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) tools will typically exclude this code from the final bundle.

```tsx
import { directive } from "./directives.js"

directive // prevents TypeScript's tree-shaking

<div use:directive />
```