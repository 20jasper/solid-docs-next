import { IfDark } from "~/components/configurable/IfConfig";

<Title> Thinking Solid </Title>

Solid's design incorporates a variety of viewpoints on principles and values that help us create better websites and applications. Knowing these underlying principles make it easier to learn and use Solid.

These particular principles will be covered in this section. To ensure that everyone understands these concepts, we will be talking about them at a high level.

## 1. Declarative Programming

Declarative programming refers to the practice of writing computer code that explains what your computer should do rather than how it accomplishes it. It's like telling your mom to make you a sandwich, without telling her how to make it. You just say "Mom, I want a sandwich" and she knows what to do.

Imperative programming operates in the opposite manner, by telling the computer how to do something step by step. It's like telling your mom how to make a sandwich: "Mom, first take two slices of bread. Next, put some peanut butter on one slice and some jelly on the other. Then, put the slices together and cut it in half." You are giving specific instructions on how to make the sandwich.

Let's take a brief look at each of these approaches.

#### Declarative

```js
let numbers = [1, 2, 3, 4, 5];
let double = numbers.map((value, i) => value * 2);
```

In the code above, we have an array of numbers called `numbers`. We then use the `map` function to create a new array called `double` that contains the values of `numbers` multiplied by 2.

The `map` function is a declarative function because it allows you to specify a transformation to be applied to each element of the array, without having to specify how that transformation is implemented.

#### Imperative

```js
let numbers = [1, 2, 3, 4, 5];
let double = [];

for (let i = 0; i < numbers.length; i++) {
  double.push(numbers[i] * 2);
}
```

In the code above, we use a for loop to iterate through each element of the array, one at a time. Inside the loop, we use the `push` method to add the result of doubling each number to a new array called `double`.

This approach is concidered imperative since we are deliberately looping through each number in the array and pushing the result of the doubling to the new array. The same task is accomplished, but the code is more intriqute and tedious.

Solid utilizes the declarative approach to programming in various areas to make it more user-friendly and easy to understand. This approach emphasizes on stating what the desired outcome is, rather than how to achieve it, making it less complex and faster to learn and use.

## 2. Vanishing Components

It's hard enough to structure your components without taking updates into consideration. Solid updates are completely independent of the components. Component functions are called once and then cease to exist. Components exist to organize your code and not much else. Here's a quick diagram of what that process looks like

<IfDark
  fallback={
    <img
      src="/images/foundations/thinking-solid/solid-simple-state-update-light.svg"
      alt="A visual representation of the steps Solid takes in updating state"
    />
  }
>
  <img
    src="/images/foundations/thinking-solid/solid-simple-state-update-dark.svg"
    alt="A visual representation of the steps Solid takes in updating state"
  />
</IfDark>

## 3. Read/Write Segregation

Precise control and predictability make for better systems. We don't need true immutability to enforce unidirectional flow, just the ability to decide which consumer can or can not write or modify data.

Solid does this in the implementation of it's primitives. Examples of these primitives are `createStore` and `createSignal` and much more.
{/* TODO: link 'more' above to the reference for primitives */}

Here's a quick example and breakdown of what we mean by Read/Write Segregation

```js
const [name, setName] = createSignal("");

const valueOfName = name(); // ðŸ‘ˆ getting

function setValueOfName(text) {
  setName(text); // ðŸ‘ˆ setting
}
```

In the above code snippet we're making use of one of Solids primitives, `createSignal`. Take note of the way getting the value of `name` is seperate from setting the value of it through the use of `setName`. This is just one of the ways Solid segregates things.

## 4. Simple Is Better Than Easy

Explicit and consistent conventions even if they require more effort are worth it. A lesson that comes hard for fine-grained reactivity. The aim is to provide minimal tools to serve as the basis to build upon. This goes back to why Solid takes a more declarative approach instead of the imperative approach.
