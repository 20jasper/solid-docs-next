import { IfDark } from "~/components/configurable/IfConfig";

<Title> Thinking Solid </Title>

Solid's design incorporates a variety of viewpoints on principles and values that help us create better websites and applications. Knowing these underlying principles make it easier to learn and use Solid.

These particular principles will be covered in this section. To ensure that everyone understands these concepts, we will be talking about them at a high level.

## 1. Declarative Programming

Declarative programming refers to the practice of writing computer code that explains what your computer should do rather than how it accomplishes it. It's like telling your mom to make you a sandwich, without telling her how to make it. You just say "Mom, I want a sandwich" and she knows what to do.

Imperative programming operates in the opposite manner, by telling the computer how to do something step by step. It's like telling your mom how to make a sandwich: "Mom, first take two slices of bread. Next, put some peanut butter on one slice and some jelly on the other. Then, put the slices together and cut it in half." You are giving specific instructions on how to make the sandwich.

Let's take a brief look at each of these approaches.

#### Declarative

```js
let numbers = [1, 2, 3, 4, 5];
let double = numbers.map((value, i) => value * 2);
```

In the piece of code above `double` is simply a copy of the values in the `numbers` array, except those values were doubled before assigning them to `double`.

#### Imperative

```js
let numbers = [1, 2, 3, 4, 5];
let double = [];

for (let i = 0; i < numbers.length; i++) {
  double.push(numbers[i] * 2);
}
```

As you can see, this piece of code accomplishes the same task as the declaritive example; however, it is more intricate and tedious.

Solid utilizes the declarative approach to programming in several areas to make it simpler and quicker to adopt and understand.

## 2. Vanishing Components

It's hard enough to structure your components without taking updates into consideration. Solid updates are completely independent of the components. Component functions are called once and then cease to exist. Components exist to organize your code and not much else. Here's a quick diagram of what that process looks like

<IfDark
  fallback={
    <img
      src="/images/foundations/thinking-solid/solid-simple-state-update-light.svg"
      alt="A visual representation of the steps Solid takes in updating state"
    />
  }
>
  <img
    src="/images/foundations/thinking-solid/solid-simple-state-update-dark.svg"
    alt="A visual representation of the steps Solid takes in updating state"
  />
</IfDark>

## 3. Read/Write Segregation

Precise control and predictability make for better systems. We don't need true immutability to enforce unidirectional flow, just the ability to decide which consumer can or can not write or modify data.

Solid does this in the implementation of it's primitives. Examples of these primitives are `createStore` and `createSignal` and much more.
{/* TODO: link 'more' above to the reference for primitives */}

Here's a quick example and breakdown of what we mean by Read/Write Segregation

```js
const [name, setName] = createSignal("");

const valueOfName = name(); // ðŸ‘ˆ getting

function setValueOfName(text) {
  setName(text); // ðŸ‘ˆ setting
}
```

In the above code snippet we're making use of one of Solids primitives, `createSignal`. Take note of the way getting the value of `name` is seperate from setting the value of it through the use of `setName`. This is just one of the ways Solid segregates things.

## 4. Simple Is Better Than Easy

Explicit and consistent conventions even if they require more effort are worth it. A lesson that comes hard for fine-grained reactivity. The aim is to provide minimal tools to serve as the basis to build upon. This goes back to why Solid takes a more declarative approach instead of the imperative approach.
