# State Management

State management refers to the way data is handled and manipulated or the information that drives the behavior and presentation of a web application. 
Solid facilitates state management through the use of reactive primitives rather than being encapsulated within the components themselves. 
This facilitates a more flexible and organized approach to managing state in applications.

Letâ€™s delve into state management concepts using a simple counter:

```jsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  const increment = () => {
    setCount(count() + 1);
  };

  return (
    <>
      <div>Current count: {count()}</div>
      <button onClick={increment}>Increment</button>
    </>
  );
}
```

1. **State (**`**count**` **)**: The state is the _data _that our application or component relies on. 
In this example, `count`  is the state which represents the current value of the counter. 
It's a source that our application reads to determine how to present itself.

2. **View (**`**<div>{count()}</div>**` **)**: The view is the _representation_ of the state to the user. 
It's what gets rendered on the page. 
In this scenario, the view is the part of the component that displays the current count to the user.

3. **Actions (**`**increment**` **)**: Actions are the functions or methods that *modify* the state based on user interactions or other events. 
In our example, `increment`  is an action that updates the state `count`  whenever it's invoked by a button click.
This structure creates a "one-way data flow", where actions modify the state, which in turn updates the view, ensuring a consistent and predictable behavior of the application.

## Managing basic state

State forms the core layer upon which components rely on to decide what data to render. 
In Solid, managing basic state can be done through the use of the `createSignal` function. Consider the following in the `Counter` component we initially started with:

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);
```

Here, the `createSignal` function is called with an initial value of `0`, initializing the state for `count`. 

<Aside>
To explore signals more, you can visit the [signals page](/essentials/signals).
</Aside>

Accessing the current value of `count` is done through `count()`:

```bash
console.log(count()); // 0
```

When it comes to updating `count`, the `setCount` function comes in. This function allows you to modify the state of `count`:

```jsx
setCount(count() + 1);
console.log(count()); // 1
```

Solid provides a simplistic way of managing state through the use of signals. 
The `setCount` function modifies the state, while `count()` allows you to access the updated state value whenever needed. 
The interaction of these two functions form the basis for managing basic state in solid.

## Rendering state in the UI

The ultimate goal of managing state is to achieve a dynamic user interface that accurately reflects data changes. 
The reactive nature of Solid ensures that the UI updates automatically in response to mirror any state changes.

Revisiting the `Counter` component presented earlier, rendering the current state of `count `is done within the return body using JSX:

```jsx
return (
  <>
    <div>Current count: {count()}</div>
    <button onClick={increment}>Increment</button>
  </>
);
```

The important thing to note here is the JSX expression `{count()}` , which is nestled within the return body of the `Counter` component. 
This expression will render the state of `count` within the DOM.

When the state of `count` changes, for instance, when the `Increment` button is clicked leading to the call of the `increment` function, the JSX expression `{count()}` will re-render the relevant portion of the DOM where it is used:

```html
// Initial render
// Current count: 0

// After clicking Increment button once
// Current count: 1
```

The expression `{count()}` represents the use of the getter function for `count` , which retrieves the current state value. 
By using the getter function within the JSX expression, Solid is able to precisely track the dependency on `count` , providing only the segment of the DOM where `count` is rendered with an update on its change. 
This leaves other parts of the DOM, such as where the button resides, unaffected.

Unnecessary re-rendering can be a performance bottleneck in web applications, leading to slow user interfaces. 
Solid's fine-grained reactivity system specifically addresses this concern by only updating the portions of the DOM directly associated with a state change, rather than re-rendering entire components or larger DOM segments. 

<Aside>
To learn more about a fine-grained reactive system, you can follow our [advanced guide] on the topic.
</Aside>

## Reacting to changes

Reacting to state changes in state is an important part of Solid's reactive system. 
The responsiveness in state changes keeps the UI in sync with the underlying data. Consider this other version of the `Counter` component:

```jsx
import { createSignal, createEffect } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);  // Initialize a new state for doubleCount

  const increment = () => {
    setCount(count() + 1);
  };

  createEffect(() => {
    setDoubleCount(count() * 2);  // Update doubleCount whenever count changes
  });

  return (
    <>
      <div>Current count: {count()}</div>
      <div>Doubled count: {doubleCount()}</div>  // Display the doubled count
      <button onClick={increment}>Increment</button>
    </>
  );
}
```

In this revised `Counter` component:

1. A new state named `doubleCount`  is introduced and initialized using `createSignal` .
2. The `createEffect`  function is employed to keep `doubleCount`  updated to be twice the value of `count`  whenever `count`  changes.
3. The updated `doubleCount`  state is then rendered to the UI, displaying the doubled count value to the user.

```html
// Initial render
// Current count: 0
// Doubled count: 0

// After clicking Increment button once
// Current count: 1
// Doubled count: 2
```

The `createEffect` function is important when reacting to state changes.  
It establishes a function to execute side-effects in response to state alterations. 
A side-effect, in this context, refers to operations or updates that affect state outside of the local environment, such as modifying a global variable or updating the DOM, which are triggered by changes in state.

## Derived state

Derived state refers to state values that are computed or derived from other state values within an application. 
This concept allows for the creation of state values that automatically update in response to changes in their dependencies. 
In Solid, derived state can be managed using the reactive primitive `createMemo` . Consider this updated version of the `Counter` component:

```jsx
import { createSignal, createEffect, createMemo } from "solid-js";

function App() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);
  const squaredCount = createMemo(() => count() * count());
  
  createEffect(() => {
    setDoubleCount(count() * 2);
  });

  return (
    <>
      <Counter count={count} setCount={setCount} />
      <DisplayCounts count={count} doubleCount={doubleCount} squaredCount={squaredCount} />
    </>
  );
}

function Counter(props) {
  const increment = () => {
    setCount(props.count() + 1);
  };

  return (
    <button onClick={increment}>Increment</button>
  );
}

function DisplayCounts(props) {
  return (
    <div>
      <div>Current count: {props.count()}</div>
      <div>Doubled count: {props.doubleCount()}</div>
      <div>Squared count: {props.squaredCount()}</div>
    </div>
  );
}
```

In this `Counter` component: 

1. A derived state named `squaredCount`  is introduced, utilizing `createMemo`  to compute the square of the `count`  value.
2. The `squaredCount`  derived state is then rendered alongside the original `count`  state in the UI, showcasing the derived state value to the user.

```html
// Initial render
// Current count: 0
// Doubled count: 0
// Squared count: 0

// After clicking Increment button three times
// Current count: 3
// Doubled count: 6
// Squared count: 9
```

Using `createMemo` allows you to define derived state that stays in sync with changes to the `count` state. 
This primitive is beneficial in managing computed properties from other state values, ensuring that they update with changes to the source state. 
It is useful for optimizing performance through memoization, creating reactive data flow, and handling data transformations.

## Lifting state

Lifting state up is a common pattern used that involves moving state to a common ancestor component so that it can be shared among various components. 
It is a technique that helps keep the [component tree](/guides/components-and-props#component-trees) in sync, and facilitates better state management.

Let's extend our previous `Counter` component example to include a sibling component that also needs access to the `count` state. 
To achieve this, you can lift the `count` state up to a common ancestor component:

```jsx
import { createSignal, createEffect, createMemo } from "solid-js";

function App() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);
  const squaredCount = createMemo(() => count() * count());
  
  createEffect(() => {
    setDoubleCount(count() * 2);
  });

  return (
    <>
      <Counter count={count} setCount={setCount} />
      <DisplayCounts doubleCount={doubleCount} squaredCount={squaredCount} />
    </>
  );
}

function Counter(props) {
  const increment = () => {
    props.setCount(props.count() + 1);
  };

  return (
    <button onClick={increment}>Increment</button>
  );
}

function DisplayCounts(props) {
  return (
    <div>
      <div>Current count: {props.count()}</div>
      <div>Doubled count: {props.doubleCount()}</div>
      <div>Squared count: {props.squaredCount()}</div>
    </div>
  );
}
```

In this setup:

1. The `count`, `doubleCount`, and `squaredCount` states are lifted to the `App` component, serving as the common ancestor for both `Counter` and `DisplayCounts` components.
2. The relevant state and state-setting functions are passed down to the `Counter` and `DisplayCounts` components as props.
3. The `Counter` component encompasses a button to increment the `count` state, while the `DisplayCounts` component renders the `doubleCount` and `squaredCount` values to the UI.

By moving the state to the `App` component, a single source of truth for the `count`, `doubleCount`, and `squaredCount` states is established. 
This creates shared access and manipulation across the `Counter` and `DisplayCounts` components. 
This pattern significantly improves maintainability and predictability in state management across the component hierarchy.

## Ready to dive deeper?

With a grasp on the basic principles of state management, you might wonder how these concepts might apply to larger, more complex applications.

In more intricate systems, basic state management might not work due to scalability, performance, maintainability, or other concerns.
This is where [stores](/essentials/stores) come into play, offering more options tailored to meet the demands of more complex applications.

If you are ready to learn about complex state management, navigate to the (complex state management page)[/guides/complex-state-management].