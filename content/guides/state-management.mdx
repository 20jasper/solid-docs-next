import { Aside } from "~/components/configurable/Aside";

# State Management

State management refers to the process of handling and manipulating data that affects the behavior and presentation of a web application.
It is an important aspect of building interactive and dynamic web applications.
Instead of encapsulating state within individual components, Solid faciliatates state management through the use of reactive primitives.
This provides a more flexible and organized approach to managing state within your applications.

These state management concepts will be shown using a basic counter example:

```jsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  const increment = () => {
    setCount(count() + 1);
  };

  return (
    <>
      <div>Current count: {count()}</div>
      <button onClick={increment}>Increment</button>
    </>
  );
}
```

There are 3 elements to state management:

1. **State (`count`)**: Represented by `count`, the state is the _data source_ that your application relies on to determine what content to display.

2. **View (`<div>{count()}</div>`)**: The view is the _visual representation_ of the state to the user.
It is the content that gets displayed on the web page.
In this example, the view is responsible for showing the current count to the user and is a key component to the overall user interface.

3. **Actions (**`**increment**` **)**: Actions are functions or methods responsible for _making changes to the state_ based on user interactions or other events. 
`increment` serves as action that updates the state `count` each time it is triggered by clicking the button.

These 3 elements work together to create a "one way data flow".
When actions modify the state, this will trigger an update in the view which will provide the user with the most up-to-date information.
This one way flow simplifies the management of data and user interactions, leading to a more predictable and maintainable application.

## Managing basic state

State serves as the core layer upon which components depend on to determine the data that will be displayed. 
In Solid, managing basic state can be done through the use of the `createSignal` function. 

In the context of the `Counter` component, the `createSignal` function is called, initializing the state for `count` with an intial value of `0`:

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);
```

To access the current value of `count`, you simply call `count()`, which is a signal getter:

```bash
console.log(count()); // 0
```

When it's time to update `count`, the `setCount` function comes in used:

```jsx
setCount(count() + 1);
console.log(count()); // 1
```

Through signals, Solid introduces a simplified way of managing state.
The `setCount` function, which represents the action, is responsible for modifying the state.
Meanwhile, `count()`, acting as the view, allows you to access the updated state value whenever needed.
Through the use of these, you will always have an up-to-date view of the application's state.

<Aside>
  If you would like to explore signals further, considering checking out the [dedicated signals page](/essentials/signals).
</Aside>

## Rendering state in the UI

The primary objective of managing state is to achieve a dynamic user interface that accurately reflects the current state of the data. 
The reactive nature of Solid ensures that the UI updates automatically in response to mirror any state changes.

Revisiting the `Counter` component presented earlier, rendering the current state of `count` is done within the return body using JSX:

```jsx
return (
  <>
    <div>Current count: {count()}</div>
    <button onClick={increment}>Increment</button>
  </>
);
```

The important thing to note here is the JSX expression `{count()}`, which is situated within curly braces in the return body of the `Counter` component. 
This expression is responsible for rendering the current state of `count` within the component.

When a change occurs in the `count` state, such as when the `Increment` button is clicked, the `increment` function is called and the JSX expression `{count()}` will trigger an update to the corresponding part of the component where it is used:

```html
// Initial render
// Current count: 0

// After clicking Increment button once
// Current count: 1
```

The expression, `{count()}`, is representative of a getter function for `count`.
This function is what retrieves the current state value and offers a way to precisely track the dependency on `count`.
Consequently, it will only update the portion of the component that is changed, leaving everything else (such as the button), unaffected.

Unnecessary re-rendering can introduce performance issues in web applications, leading to slow user interfaces.
This is addressed through Solid's fine-grained reactivity system which focuses on updating only specific portions of the DOM directly associated with a state change.
In preventing the need to re-render entire components or larger DOM segements, UI will remain more efficient and responsive for the user.

<Aside>
  For more information, check out the guide on [understanding fine-grained reactivity](/guides/fine-grained-reactivity).
</Aside>

## Reacting to changes

In a reactive system, it is important that the UI mirrors changes in state.
This responsiveness to state changes keeps the UI in sync with the underlying data.

Consider this other version of the `Counter` component:

```jsx
import { createSignal, createEffect } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);  // Initialize a new state for doubleCount

  const increment = () => {
    setCount(count() + 1);
  };

  createEffect(() => {
    setDoubleCount(count() * 2);  // Update doubleCount whenever count changes
  });

  return (
    <>
      <div>Current count: {count()}</div>
      <div>Doubled count: {doubleCount()}</div>  // Display the doubled count
      <button onClick={increment}>Increment</button>
    </>
  );
}
```

In this revised `Counter` component:

1. A new state named `doubleCount` is initialized using `createSignal` .
2. The `createEffect` is introduced to make sure that `doubleCount` remains updated, setting it to double the value of `count` whenever `count` undergoes a change.
3. The updated `doubleCount` state is then rendered to the UI, displaying the doubled count value to the user.

```html
// Initial render

// Current count: 0
// Doubled count: 0

// After clicking Increment button once

// Current count: 1
// Doubled count: 2
```

The [`createEffect`](/reference/createEffect) function is important when reacting to state changes.  
It sets up functions to perform side effects whenever the state is modified.
Here, a side-effect refers to operations or updates that affect state outside of the local environment - like modifying a global variable or updating the DOM - triggered by those state changes.

## Derived state

Derived state is a reflection of other state values that are recalculated whenever its dependencies change.

[`createMemo`](/reference/createMemo) is a reactive primitive that facilitates this:

```jsx
import { createSignal, createEffect, createMemo } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);
  const squaredCount = createMemo(() => count() * count());

  const increment = () => {
    setCount(count() + 1);
  };
  
  createEffect(() => {
    setDoubleCount(count() * 2);
  });

  return (
    <>
      <button onClick={increment}>Increment</button>
      <div>
        <div>Current count: {count()}</div>
        <div>Doubled count: {doubleCount()}</div>
        <div>Squared count: {squaredCount()}</div>
      </div>
    </>
  );
}
```

In the revised `Counter` component, a derived state called `squaredCount` is initialized. 
Using `createMemo`, it calculates the square of the count value. 
The component then displays `squaredCount` alongside the primary `count`, offering a view of both the original and derived state values.

```html
// Initial render

// Current count: 0
// Doubled count: 0
// Squared count: 0

// After clicking Increment button three times

// Current count: 3
// Doubled count: 6
// Squared count: 9
```

Using `createMemo` allows you to define derived state that stays in sync with changes to the `count` state. 
This primitive is useful for managing computed properties from other state values through memoization.
 creating reactive data flow, and handling data transformations.

## Lifting state

Lifting state up involves moving state to a common ancestor component so that it can be shared among various components.
While state is not tied to components, you may want to link multiple components together in order to access and manipulate the same piece of state.
This can keep things synchronized across the [component tree](/guides/components-and-props#component-trees) and facilitates more efficient state management.

When adding another component sibling to the `Counter` example that requires access to the count state, you can move the count state to a shared parent component:

```jsx
import { createSignal, createEffect, createMemo } from "solid-js";

function App() {
  const [count, setCount] = createSignal(0);
  const [doubleCount, setDoubleCount] = createSignal(0);
  const squaredCount = createMemo(() => count() * count());
  
  createEffect(() => {
    setDoubleCount(count() * 2);
  });

  return (
    <>
      <Counter count={count()} setCount={setCount} />
      <DisplayCounts count={count()} doubleCount={doubleCount()} squaredCount={squaredCount()} />
    </>
  );
}

function Counter(props) {
  const increment = () => {
    props.setCount(props.count() + 1);
  };

  return (
    <button onClick={increment}>Increment</button>
  );
}

function DisplayCounts(props) {
  return (
    <div>
      <div>Current count: {props.count}</div>
      <div>Doubled count: {props.doubleCount}</div>
      <div>Squared count: {props.squaredCount}</div>
    </div>
  );
}

export default App;
```

Modifying the previous code, you would end up with the following:

1. The `count`, `doubleCount`, and `squaredCount` states lifted to the `App` component, which serves as the common ancestor for both the `Counter` and `DisplayCounts` components.
2. The relevant state and state-setting functions are passed down to the `Counter` and `DisplayCounts` components as props.
3. The `Counter` component encompasses a button to increment the `count` state, while the `DisplayCounts` component renders the `doubleCount` and `squaredCount` values to the UI.

By moving the state to the `App` component, a single source of truth for the `count`, `doubleCount`, and `squaredCount` states is established. 
This creates shared access and manipulation across the `Counter` and `DisplayCounts` components. 
This pattern significantly improves maintainability and predictability in state management across the component hierarchy.

<Aside>
  To encourage one-way data flow, props are passed as read-only or immutable values from the parent to child components.
  While props are primarily read-only, there are [specific utlity functions for props](/essentials/components-and-props/#component-props) that offer methods to interact with props beyond their inherent read-only nature.
  In addition, to facilitate state changes in child components, you can pass down setter functions from the parent, allowing the child to indirectly modify the parent's state.
</Aside>

## Ready to dive deeper?

From the examples given above, managing a variety of signals, memos, functions, and other elements can become challenging as applications grow. 
With managing state being important, these ways of handling it may fall short due to issues like scalability, performance, or maintainability.

This is where [stores](/essentials/stores) come in, offering options tailored to meet the demands of more complex applications.

If you are ready to learn about complex state management, navigate to the [complex state management page](/guides/complex-state-management).