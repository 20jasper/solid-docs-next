# Fetching Data

For most modern web applications, data fetching is a common task. Solid provide a built-in utility, `createResource` , that was created to simplify data fetching, especially for asynchronous operations.

## What is `createResource` ?

`createResource` is a specialized signal designed specifically for managing asynchronous data fetching. It wraps around async operations, providing a way to handle various states: loading, success, and error.

This function is non-blocking, meaning that `createResource` guarantees that the application remains responsive, even during the retrieval of information. This prevents the common pitfalls of traditional async handling, such as unresponsive UIs during data fetching.

## Using `createResource`

****`createResource` requires a function that returns a promise as its argument. Upon its call, `createResource` returns a signal which has reactive properties like loading, error, latest, etc. These properties can be used to conditionally render JSX based on the current reactive state:

```jsx
import { createResource, Switch, Match, Show } from "solid-js";

const fetchUser = async () =>
 {
  const response = await fetch(`https://swapi.dev/api/people/`);
  return response.json();
  }

function App() {

  const [user, { loading, error}] = createResource(fetchUser);

  return (
    <div>
      <Show when={user.loading}>
        <p>Loading...</p>
      </Show>
      <Switch>
        <Match when={user.error}>
          <span>Error: {error()}</span>
        </Match>
        <Match when={user()}>
          <div>{JSON.stringify(user().results)}</div>
        </Match>
      </Switch>

    </div>
  );
}
```

With this example, a fetcher function was created that makes a call to get a user, and this function is passed in as an argument to `createResource` . The signal returned from the `createResource` provided properties that conditionally rendered JSX based on the current reactive state.

In addition to this, `createResource` can also take in a source signal as the first argument, and the async fetcher function as the second. The source signal is provided as the query to the async fetcher function, which then returns a promise. A change in the source signal calls an internal fetch method to fetch new data based on this change:

```jsx
import { createSignal, createResource, Switch, Match, Show } from "solid-js";

const fetchUser = async (id) =>
 {
  const response = await fetch(`https://swapi.dev/api/people/${id}/`));
  return response.json();
}

function App() {
  const [userId, setUserId] = createSignal();
  const [user] = createResource(userId, fetchUser);

  return (
    <div>
      <input 
        type="number"
        min="1"
        placeholder="Enter Numeric Id"
        onInput={(e) => setUserId(e.currentTarget.value)}
      />
      <Show when={user.loading}>
        <p>Loading...</p>
      </Show>
      <Switch>
        <Match when={user.error}>
          <span>Error: {error()}</span>
        </Match>
        <Match when={user()}>
          <div>{JSON.stringify(user())}</div>
        </Match>
      </Switch>

    </div>
  );
}
```

Here, the internal fetch method will be called anytime that the signal value changes. If another number is entered into the input, `createResource` is aware of the change and will fetch new data based on the new signal value.

## Calling multiple async events

While `createResource` can be used on its own, Solid also provides another way to coordinate the display of multiple asynchronous events. `Suspense`  serves as a boundary that can show a fallback placeholder instead of the partially loaded contents as these async events resolve.

```jsx
import { createSignal, createResource, Switch, Match, Suspense } from "solid-js";

const fetchUser = async (id) => {
  const response = await fetch(`https://swapi.dev/api/people/${id}/`);
  return response.json();
 }

function App() {
  const [userId, setUserId] = createSignal();
  const [user] = createResource(userId, fetchUser);

  return (
    <div>
    <input 
      type="number"
      min="1"
      placeholder="Enter Numeric Id"
      onInput={(e) => setUserId(e.currentTarget.value)}
    />
      <Suspense fallback={<div>Loading...</div>}>

        <Switch>
          <Match when={user.error}>
            <span>Error: {error()}</span>
          </Match>
          <Match when={user()}>
            <div>{JSON.stringify(user())}</div>
          </Match>
        </Switch>
      </Suspense>
    </div>
  );
}
```

`Suspense` automatically detects any descendant async reads and responds accordingly. This improves the user experience through removing any unnecessary components that may be present because of multiple intermediate and partial loading states. `Suspense` can nest as many components as needed, however, only the nearest ancestor will transform to `fallback` when the `loading` state is detected.

## Dynamic data handling

With the second output of `createResource`, there are 2 powerful methods designed to enhance and simplify some complex aspects of data management:

### `mutate`

In scenarios where prompt feedback or responsiveness is required, `mutate` allows for "optimistic mutations". These mutations provide immediate feedback, even when background processes like server confirmations, are still underway.

This method becomes useful in applications like to do lists where, as soon as the user inputs a task and selects the `Add` button, the list will refresh immediately, irregardless of the data communication happening with the server. This improves application responsiveness and speed.

### `refetch`

In situations where real-time feedback is important, `refetch` will reload the current query irregardless of changes.

This kind of method becomes useful in situations where data is constantly changing. For instance with real-time information, such as financial applications, this feature becomes beneficial. The `refetch` method provides users the latest information, crucial in displaying the most recent values.
