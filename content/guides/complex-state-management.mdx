import { Aside } from "~/components/configurable/Aside"

# Complex State Management

As applications grow and start to involve many components, more intricate user interactions, and possibly communication with backend services, you may find that staying organized with more [basic state management methods](/guides/state-management) can become difficult to maintain.

Consider this example:

```jsx
import { For, createSignal, Show, createMemo } from 'solid-js';

const App = () => {
  const [tasks, setTasks] = createSignal([]);
  const [numberOfTasks, setNumberOfTasks] = createSignal(tasks.length);
  let input;

  const addTask = (text) => {
    setTasks([...tasks(), { id: tasks().length, text, completed: false }]);
    setNumberOfTasks(numberOfTasks() + 1);
  };
  const toggleTask = (id) => {
    setTasks(
      tasks().map((task) =>
        task.id !== id ? task : { ...task, completed: !task.completed }
      )
    );
  };

  const removeTask = (id) => {
    setTasks(tasks().filter((task) => task.id !== id));
    setNumberOfTasks(numberOfTasks() - 1);
  };


  const completedTasks = createMemo(() => {
    let completed = 0;
    for (let task of tasks()) {
      if (task.completed === true) completed++
    }
    return completed;
  })

  return (
    <>
      <h1>My list</h1>
      <span>You have {numberOfTasks()} task(s) today!</span>
      <div>
        <input ref={input} />
        <button
          onClick={(e) => {
            if (!input.value.trim()) return;
            addTask(input.value);
            input.value = '';
          }}
        >
          Add Task
        </button>
      </div>
      <For each={tasks()}>
        {(task) => {
          const { id, text } = task;
          console.log(`Creating ${text}`);
          return (
            <div>
              <input
                type="checkbox"
                checked={task.completed}
                onChange={[toggleTask, id]}
              />
              <span
                style={{
                  'text-decoration': task.completed ? 'line-through' : 'none',
                }}
              >
                {text}
              </span>
              <button onClick={() => removeTask(id)}>x</button>
            </div>
          );
        }}
      </For>
      <Show when={completedTasks() !== 0}>
        <span>You have completed {completedTasks()} task(s) today!</span>
      </Show>
    </>
  );
};

export default App;
```

There are several challenges to managing state in this way:

* Increased verbosity with the multiple `createSignal` calls for `tasks`, `numberOfTasks`, as well as a `createMemo` function for `completedTasks`.
Additionally, with each state update, there requires manual updates to other related states which risks the application becoming out of sync.

* While Solid is optimized, this components design leads to frequent recalculations, such as updating `completedTasks` with every toggle action, which can negatively impact performance.
In addition, the dependence on the component's logic on the current state for `numberOfTasks` and `completedTasks` can complicate code understanding.

As an application like this scales, managing state in this manner becomes even more complex.
Introducing other dependent state variables would require updates across the *entire* component which would likely introduce more errors.
This would likely make it more difficult to separate specific functionalities into distinct, reusable components without transferring a substantial portion of state management logic, as well.

## Introducing stores

Solid's answer to this is [**stores**](/essentials/stores).
Stores simplify state management through creating a centralized location for logic, which will reduce code redundancy.
Stores use immutable patterns to make it easier to manage reactivity and flow of data, which make them a better candidate for more complex state management scenarios.

Through recreating this list using Stores, you will see how stores can improve the readability and management of your code.

## Creating a store

Similar to [signals](/essentials/signals), stores are a way to store state.
However, while signals are designed to hold individual values, stores can contain a collection, where each element can be a signal.

Toreduce the amount of signals that were used in the original example, you can do the following using a store:

```jsx
import { createStore } from "solid-js/store"

const App = () => {
  const [state, setState] = createStore({
          tasks: [],
          numberOfTasks: 0,
          completedTasks: 0,
      });

}

export default App;
```

Through using a store, you no longer need need to keep track of separate signals for `tasks`, `numberOfTasks`, and `completedTasks`.

## Accessing values

Properties within a store are accessible through a read-only proxy, `state` in this example, that is the first value returned by the `createStore` function.
This method ensures that your component consistently reflects the current value of the store's properties:

```jsx
  import { createStore } from "solid-js/store"

const App = () => {
  const [state, setState] = createStore({
          tasks: [],
          numberOfTasks: 0,
          completedTasks: 0,
      });
  return (
    <>
      <h1>My Task List for Today</h1>
      <span>You have {state.numberOfTasks} task(s) for today!</span>
    </>
  )
}

export default App;
```

## Updating stores

When you want to modify a store, you use the `setState` function.
This setter is provided as the second value returned by `createStore`.
The purpose of this setter is to provide a means for reactively updating the store, which then keeps any component or computations dependent on the store updated whenever the store's state changes.

```jsx
import { For, createEffect, Show } from 'solid-js';
import { createStore } from 'solid-js/store';

const App = () => {
  let input; // lets you target the input value
  const [state, setState] = createStore({
    tasks: [],
    numberOfTasks: 0,
    completedTasks: 0,
  });

  const addTask = (text) => {
    setState('tasks', state.tasks.length,
      { id: state.tasks.length, text, completed: false });
  };

  const toggleTask = (id) => {
    const currentCompletedStatus = state.tasks[id].completed;
    setState(
      `tasks`,
      (task) => task.id === id,
      `completed`,
      !currentCompletedStatus
    );
    if (currentCompletedStatus) {
      setState('completedTasks', state.completedTasks - 1);
    } else {
      setState('completedTasks', state.completedTasks + 1);
    }
    console.log(state.tasks);
  };

   createEffect(() => {
    setState('numberOfTasks', state.tasks.length);
  });

  return (
    <>
      <div>
        <h1>My Task List for Today</h1>
        <span>You have {state.numberOfTasks} task(s) for today!</span>
      </div>
      <input ref={input} />
      <button
        onClick={(e) => {
          if (!input.value.trim()) return;
          addTask(input.value);
          input.value = '';
        }}
      >
        Add Task
      </button>
      <For each={state.tasks}>
        {(task) => {
          const { id, text } = task;
          return (
            <div>
              <input
                type="checkbox"
                checked={task.completed}
                onChange={() => toggleTask(task.id)}
              />
              <span>{text}</span>
            </div>
          );
        }}
      </For>
      <Show when={state.completedTasks !== 0}>
        <span>You have completed {state.completedTasks} task(s)!</span>
      </Show>
    </>
  );
};

export default App;
```

### Adding to an array

To add an element to an array, in this case the new task, you can append to the next index of the array through `state.tasks.length`. 
By pinpointing the `tasks` key in combination with the upcoming position, the new task is added to the end of the array.

### Reactivity in stores

While stores provide a reactive way to manage state, the signals that they rely on are created lazily.
What this means, is that these signals are only tracked when accessed through a reactive scope.
For example, setting the `numberOfTasks` property directly under `createStore`, such as `setState("numberOfTasks", state.tasks.length)`, will **not** update `numberOfTasks` with each new task.
Rather, you have to access the `numberOfTasks` property in a tracking scope, such as within a [`createEffect`](/reference/createEffect). 
Through the `createEffect`, `numberOfTasks` will then reflect the existing number of tasks in the list.

### Navigating and modifying nested properties

One important feature of the setter functions in stores is their path syntax. 
This allows you to identify the state's keys as the initial arguments and provide the new value for the identified key as the last one. 

If you have worked with JavaScript, this might remind you of how to assign a value in an object: `object[key] = newValue`.
For stores, however, the setter would require the following: `setStore("key", value)`.
In `addTask` function in the example above, it appends onto the `tasks` array through `setState("tasks", state.tasks.length, { id: state.tasks.length, text, completed: false })`, an example of this path syntax in action.

<Aside>
  **Note**: Solid's `setState` offers flexibility with filtering properties. 
  This is shown through the `toggleTask` function, which is used to find the selected task's `id`.
  
  While this is one way to filter, other methods for such as [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), [`find`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find), and [`startsWith`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith), can offer other ways to target specific items or keys.
</Aside>

#### Mutating state with `produce`

Even with the many capabilities of `setState`, there are instances where you may want to work with the writeable proxy version of your store.
The `produce` method was created to facilitate working with immutable data structures in a more mutuable-fashion. 
This method provides a way to perform mutations as if working with regular JavaScript objects but, upon completion, produces a *new state* with all the changes applied in an **immutable** manner.

For instance, updating `addTask` and `toggleTask` to integrate the `produce` method would look like the following:

```jsx
const addTask = (text) => {
    setState(
      'tasks',
      produce((task) => {
        task.push({ id: state.tasks.length, text, completed: false });
      })
    );
  };

  const toggleTask = (id) => {
    setState(
      'tasks',
      (tasks) => tasks.id === id,
      produce((task) => {
        task.completed = !task.completed;
      })
    );
  };
```

Some advantages to using `produce`:
*  Handling deeply nested state objects or arrays with `produce` eliminates the verbosity often associated with the `setState` path syntax.

* `produce` ensures that the original state is untouched.
This reduces the risk of unexpected mutations and the bugs they can introduce.

* It only generates a new object when there's a change.

* In more complex applications, `produce` offers a structured and consistent approach to state updates, making the codebase easier to manage and debug.

<Aside>
  Another benefit to working with `produce` is that it offers a way to modify a store without having to make multiple `setStore` calls.

  ```jsx
    // without produce
    batch(() => {
      setState(0, 'text', "I'm updated text")
      setState(0, 'completed', true)
    })

    // with produce
    setState(0,
    produce((task) => {
      task.text = "I'm updated text",
      task.completed = true
    }))
  ```
</Aside>

To learn more about stores and the utilities it provides, visit the the [store's information page](/essentials/stores).